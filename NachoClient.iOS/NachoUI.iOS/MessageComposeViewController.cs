// This file has been autogenerated from a class added in the UI designer.

using System;
using System.IO;
using System.Drawing;
using System.Collections.Generic;

using MonoTouch.Foundation;
using MonoTouch.UIKit;

using MimeKit;

using NachoCore.Model;
using NachoCore.Utils;
using System.Text;

using NachoCore.Brain;
using NachoCore;

namespace NachoClient.iOS
{
    public partial class MessageComposeViewController : UIViewController, IUcAddressBlockDelegate, IUcAttachmentBlockDelegate, INachoContactChooserDelegate, INachoFileChooserParent, INachoDateControllerParent, INachoIntentChooserParent
    {
        // The reason for sending this message
        protected enum Action
        {
            Send,
            Reply,
            ReplyAll,
            Forward,
        };

        // Strings to be used when calling SetAction()
        public static readonly string REPLY_ACTION = "Reply";
        public static readonly string REPLY_ALL_ACTION = "ReplyAll";
        public static readonly string FORWARD_ACTION = "Forward";

        public INachoMessageEditorParent owner;

        protected McAccount account;
        protected McCalendar calendarInviteItem;

        protected McEmailMessage mcMessage = new McEmailMessage ();
        protected McBody mcBody = new McBody ();

        protected McEmailMessage referencedMessage;
        // The message being forwarded or replied to, if any
        protected Action action;
        // The reason for sending this message

        protected bool calendarInviteIsSet;
        bool suppressLayout;
        float keyboardHeight;

        UcAddressBlock toView;
        UcAddressBlock ccView;
        UcAddressBlock bccView;
        UcAttachmentBlock attachmentView;

        UILabel subjectLabel;
        UITextField subjectField;
        UIView intentView;
        UILabel intentLabel;
        UILabel intentDisplayLabel;
        bool alwaysShowIntent;

        UITextView bodyTextView;

        UIView toViewHR;
        UIView ccViewHR;
        UIView bccViewHR;
        UIView subjectLabelHR;
        UIView intentLabelHR;
        UIView attachmentViewHR;

        NcEmailAddress PresetToAddress;
        string PresetSubject;
        string EmailTemplate;
        List<McAttachment> PresetAttachmentList;
        bool startInSubjectField;
        bool startInBodyField;

        // If this is a reply or forward, keep track of the quoted text that is inserted.
        // This makes it possible to check later if the user changed the text.
        private string initialQuotedText = null;
        protected UIFont labelFont = A.Font_AvenirNextMedium14;
        protected UIColor labelColor = A.Color_NachoDarkText;

        protected float LINE_HEIGHT = 42;
        protected float LEFT_INDENT = 15;
        protected float RIGHT_INDENT = 15;
        protected float BODY_LEFT_MARGIN = 10;
        protected float BODY_RIGHT_MARGIN = 10;
        protected float BODY_BOTTOM_MARGIN = 10;

        protected NcQuickResponse.QRTypeEnum QRType = NcQuickResponse.QRTypeEnum.None;

        UIBarButtonItem sendButton;
        UIBarButtonItem cancelButton;
        UIBarButtonItem quickResponseButton;
        public NcMessageIntent messageIntent;
        protected MessageDeferralType intentDateType;

        public MessageComposeViewController (IntPtr handle) : base (handle)
        {
        }

        public void SetOwner (INachoMessageEditorParent o)
        {
            owner = o;
        }

        public void SetQRType (NcQuickResponse.QRTypeEnum QRType)
        {
            this.QRType = QRType;
        }

        // Can be called by owner to set a pre-existing To: address, subject, email template and/or attachment
        public void SetEmailPresetFields (NcEmailAddress toAddress = null, string subject = null, string emailTemplate = null, List<McAttachment> attachmentList = null, bool isQR = false)
        {
            PresetToAddress = toAddress;
            PresetSubject = subject;
            EmailTemplate = emailTemplate;
            PresetAttachmentList = attachmentList;
            alwaysShowIntent = !String.IsNullOrEmpty (PresetSubject);
            startInSubjectField = (null != PresetToAddress) && String.IsNullOrEmpty (PresetSubject);
            startInBodyField = (null != PresetToAddress) && !String.IsNullOrEmpty (PresetSubject) && !String.IsNullOrEmpty (emailTemplate);
        }

        public override void ViewDidLoad ()
        {
            base.ViewDidLoad ();

            account = NcModel.Instance.Db.Table<McAccount> ().Where (x => x.AccountType == McAccount.AccountTypeEnum.Exchange).FirstOrDefault ();

            sendButton = new UIBarButtonItem ();
            cancelButton = new UIBarButtonItem ();
            quickResponseButton = new UIBarButtonItem ();

            Util.SetAutomaticImageForButton (quickResponseButton, "contact-quickemail");
            Util.SetAutomaticImageForButton (cancelButton, "icn-close");
            Util.SetAutomaticImageForButton (sendButton, "icn-send");

            NavigationItem.LeftBarButtonItem = cancelButton;

            NavigationItem.RightBarButtonItems = new UIBarButtonItem[] {
                sendButton,
                quickResponseButton,
            };

            quickResponseButton.Clicked += (object sender, EventArgs e) => {
                View.EndEditing (true);
                if (IsReplyAction ()) {
                    QRType = NcQuickResponse.QRTypeEnum.Reply;
                } else if (IsForwardAction ()) {
                    QRType = NcQuickResponse.QRTypeEnum.Forward;
                } else {
                    QRType = NcQuickResponse.QRTypeEnum.Compose;
                }
                ShowQuickResponses ();
            };

            sendButton.Clicked += (object sender, EventArgs e) => {
                if (OkToSend ()) {
                    SendMessage ();
                    owner = null;
                    NavigationController.PopViewControllerAnimated (true);
                }
            };

            cancelButton.Clicked += (sender, e) => {
                View.EndEditing (true);
                UIAlertView alert = new UIAlertView ();
                alert.Title = "Are you sure?";
                alert.Message = "This message will not be saved";
                alert.AddButton ("Cancel");
                alert.AddButton ("Yes");
                alert.CancelButtonIndex = 0;
                alert.Dismissed += (object alertSender, UIButtonEventArgs alertEvent) => {
                    if (1 == alertEvent.ButtonIndex) {
                        owner = null;
                        NavigationController.PopViewControllerAnimated (true);
                    }
                };
                alert.Show ();
            };

            suppressLayout = true;

            CreateView ();

            if (IsForwardOrReplyAction ()) {
                InitializeMessageForAction ();
            }

            suppressLayout = false;
                
            if (IsReplyAction ()) {
                ConfigureBodyEditView (false);
                bodyTextView.BecomeFirstResponder ();
                bodyTextView.SelectedRange = new NSRange (0, 0);
            } else if (startInSubjectField) {
                ConfigureSubjectEditView (false);
                subjectField.BecomeFirstResponder ();
            } else if (startInBodyField) {
                ConfigureBodyEditView (false);
                bodyTextView.BecomeFirstResponder ();
                bodyTextView.SelectedRange = new NSRange (EmailTemplate.Length, 0);
            } else if (calendarInviteIsSet) {
                toView.SetEditFieldAsFirstResponder ();
            } else {
                ConfigureToView (false);
                toView.SetEditFieldAsFirstResponder ();
            }
        }

        public override void ViewWillAppear (bool animated)
        {
            base.ViewWillAppear (animated);
            if (null != this.NavigationController) {
                if (this.NavigationController.RespondsToSelector (new MonoTouch.ObjCRuntime.Selector ("interactivePopGestureRecognizer"))) {
                    this.NavigationController.InteractivePopGestureRecognizer.Enabled = false;
                }
            }
            if (HandlesKeyboardNotifications) {
                NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillHideNotification, OnKeyboardNotification);
                NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillShowNotification, OnKeyboardNotification);
            }

            if (NcQuickResponse.QRTypeEnum.None != QRType) {
                ShowQuickResponses ();
            }


        }

        public override void ViewWillDisappear (bool animated)
        {
            base.ViewWillDisappear (animated);
            if (null != this.NavigationController) {
                this.NavigationController.ToolbarHidden = true;
            }
            if (HandlesKeyboardNotifications) {
                NSNotificationCenter.DefaultCenter.RemoveObserver (UIKeyboard.WillHideNotification);
                NSNotificationCenter.DefaultCenter.RemoveObserver (UIKeyboard.WillShowNotification);
            }

            QRType = NcQuickResponse.QRTypeEnum.None;
        }

        public virtual bool HandlesKeyboardNotifications {
            get { return true; }
        }

        public override bool HidesBottomBarWhenPushed {
            get {
                return this.NavigationController.TopViewController == this;
            }
        }

        public override void PrepareForSegue (UIStoryboardSegue segue, NSObject sender)
        {
            var blurry = segue.DestinationViewController as BlurryViewController;
            if (null != blurry) {
                blurry.CaptureView (this.View);
            }

            if (segue.Identifier.Equals ("ComposeToContactChooser")) {
                var dc = (INachoContactChooser)segue.DestinationViewController;
                var holder = sender as SegueHolder;
                var address = (NcEmailAddress)holder.value;
                dc.SetOwner (this, address, NachoContactType.EmailRequired);
                return;
            }
            if (segue.Identifier.Equals ("ComposeToContactSearch")) {
                var dc = (INachoContactChooser)segue.DestinationViewController;
                var holder = sender as SegueHolder;
                var address = (NcEmailAddress)holder.value;
                dc.SetOwner (this, address, NachoContactType.EmailRequired);
                return;
            }
            if (segue.Identifier.Equals ("ComposeToNachoNow")) {
                return;
            }
            if (segue.Identifier == "SegueToQuickResponse") {
                var vc = (QuickResponseViewController)segue.DestinationViewController;
                vc.SetOwner (this);
                vc.SetProperties (QRType, ref mcMessage);
                return;
            }
            if (segue.Identifier == "SegueToIntentSelection") {
                var vc = (IntentSelectionViewController)segue.DestinationViewController;
                vc.SetOwner (this);
                vc.SetDateControllerOwner (this);

                if (null == messageIntent) {
                    mcMessage.Subject = subjectField.Text;
                    messageIntent = new NcMessageIntent ();
                }

                return;
            }

            if (segue.Identifier.Equals ("SegueToAddAttachment")) {
                var dc = (AddAttachmentViewController)segue.DestinationViewController;
                dc.SetOwner (this);
                return;
            }

            Log.Info (Log.LOG_UI, "Unhandled segue identifer {0}", segue.Identifier);
            NcAssert.CaseError ();
        }

        protected void CreateView ()
        {
            View.BackgroundColor = UIColor.White;
            scrollView.BackgroundColor = UIColor.White;

            contentView.BackgroundColor = UIColor.White;
            contentView.Layer.CornerRadius = 6;
            contentView.Layer.MasksToBounds = true;

            toView = new UcAddressBlock (this, "To:", null, View.Frame.Width);
            ccView = new UcAddressBlock (this, "Cc:", "Cc/Bcc:", View.Frame.Width);
            bccView = new UcAddressBlock (this, "Bcc:", null, View.Frame.Width);

            toViewHR = new UIView (new RectangleF (0, 0, View.Frame.Width, 1));
            toViewHR.BackgroundColor = A.Color_NachoNowBackground;

            ccViewHR = new UIView (new RectangleF (0, 0, View.Frame.Width, 1));
            ccViewHR.BackgroundColor = A.Color_NachoNowBackground;

            bccViewHR = new UIView (new RectangleF (0, 0, View.Frame.Width, 1));
            bccViewHR.BackgroundColor = A.Color_NachoNowBackground;

            subjectLabelHR = new UIView (new RectangleF (0, 0, View.Frame.Width, 1));
            subjectLabelHR.BackgroundColor = A.Color_NachoNowBackground;

            intentLabelHR = new UIView (new RectangleF (0, 0, View.Frame.Width, 1));
            intentLabelHR.BackgroundColor = A.Color_NachoNowBackground;

            attachmentViewHR = new UIView (new RectangleF (0, 0, View.Frame.Width, 1));
            attachmentViewHR.BackgroundColor = A.Color_NachoNowBackground;

            subjectLabel = new UILabel ();
            subjectLabel.Text = "Subject: ";
            subjectLabel.Font = labelFont;
            subjectLabel.TextColor = labelColor;
            subjectLabel.SizeToFit ();

            subjectField = new UITextField ();
            subjectField.Font = labelFont;
            subjectField.TextColor = labelColor;
            subjectField.Placeholder = "";
            if (!String.IsNullOrEmpty (PresetSubject)) {
                alwaysShowIntent = true;
                subjectField.Text += PresetSubject;
            }
            subjectField.SizeToFit ();

            intentView = new UIView ();
            intentView.BackgroundColor = UIColor.White;

            intentLabel = new UILabel ();
            intentLabel.Text = "Intent:";
            intentLabel.Font = labelFont;
            intentLabel.TextColor = labelColor;
            intentLabel.SizeToFit ();
            alwaysShowIntent = false;

            intentDisplayLabel = new UILabel ();
            intentDisplayLabel.Font = labelFont;
            intentDisplayLabel.TextColor = labelColor;
            intentDisplayLabel.Text = "NONE";
            intentDisplayLabel.SizeToFit ();

            UITapGestureRecognizer intentTap = new UITapGestureRecognizer (() => {
                View.EndEditing (true);
                PerformSegue ("SegueToIntentSelection", this);
            });
            intentView.AddGestureRecognizer (intentTap);
            intentView.UserInteractionEnabled = true;

            Util.AddArrowAccessory (contentView.Frame.Width - 15 - 12, 14, 12, intentView);

            intentView.AddSubviews (new UIView[] { intentLabel, intentDisplayLabel });

            attachmentView = new UcAttachmentBlock (this, account.Id, View.Frame.Width, 40, true);

            bodyTextView = new UITextView (new RectangleF (0, 0, View.Frame.Width, 0));
            bodyTextView.Font = labelFont;
            bodyTextView.TextColor = labelColor;
            bodyTextView.BackgroundColor = UIColor.White;
            bodyTextView.TextContainerInset = new UIEdgeInsets (0, BODY_LEFT_MARGIN, BODY_BOTTOM_MARGIN, BODY_RIGHT_MARGIN);
            bodyTextView.ScrollEnabled = false;

            if (EmailTemplate != null) {
                bodyTextView.InsertText (EmailTemplate);
            }
            if (!String.IsNullOrEmpty (account.Signature)) {
                bodyTextView.InsertText ("\n" + "\n" + account.Signature);
            }
            var beginningRange = new NSRange (0, 0);
            bodyTextView.SelectedRange = beginningRange;

            //Need to be able to inserthtml here, but for now will do simple text input
            //bodyTextView.InsertText ("<html><head></head><body>This message sent by <a href='http://www.nachocove.com'>NachoMail</a></body></html>");

            contentView.AddSubviews (new UIView[] {
                toView,
                toViewHR,
                ccView,
                ccViewHR,
                bccView,
                bccViewHR,
                subjectLabel,
                subjectLabelHR,
                subjectField,
                intentView,
                intentLabelHR,
                attachmentView,
                attachmentViewHR,
            });

            scrollView.AddSubview (bodyTextView);

            subjectField.EditingDidBegin += (object sender, EventArgs e) => {
                ConfigureSubjectEditView (true);
            };
                
            bodyTextView.Started += (object sender, EventArgs e) => {
                ConfigureBodyEditView (true);
            };

            bodyTextView.Changed += (object sender, EventArgs e) => {
                SelectionChanged (bodyTextView);
            };

            if (PresetToAddress != null) {
                UpdateEmailAddress (null, PresetToAddress);
            }

            if (PresetAttachmentList != null) {
                foreach (var attachment in PresetAttachmentList) {
                    attachmentView.Append (attachment);
                }
            }

//            attachmentView.BackgroundColor = UIColor.Yellow;
//            bodyTextView.BackgroundColor = UIColor.Gray;
//            contentView.BackgroundColor = UIColor.Green;
//            scrollView.BackgroundColor = UIColor.Red;
//            View.BackgroundColor = UIColor.Cyan;
        }

        protected void ConfigureToView (bool animate)
        {
            toView.Hidden = false;
            ccView.Hidden = false;
            bccView.Hidden = true;
            attachmentView.Hidden = calendarInviteIsSet; 

            toView.SetCompact (false, -1);
            ccView.SetCompact (true, -1);
            bccView.SetCompact (true, -1);
            attachmentView.SetCompact (false);

            toViewHR.Hidden = false;
            ccViewHR.Hidden = false;
            bccViewHR.Hidden = true;
            attachmentViewHR.Hidden = false;

            intentView.Hidden = !alwaysShowIntent;
            intentLabelHR.Hidden = !alwaysShowIntent;

            suppressLayout = true;
            toView.ConfigureView ();
            ccView.ConfigureView ();
            bccView.ConfigureView ();
            attachmentView.ConfigureView ();
            suppressLayout = false;

            if (animate) {
                LayoutView ();
            } else {
                LayoutWithoutAnimation ();
            }
        }

        protected void ConfigureCcView (bool animate)
        {
            toView.Hidden = false;
            ccView.Hidden = false;
            bccView.Hidden = false;
            attachmentView.Hidden = (calendarInviteIsSet ? true : false); 

            toView.SetCompact (false, -1);
            ccView.SetCompact (false, -1);
            bccView.SetCompact (false, -1);
            attachmentView.SetCompact (false);

            toViewHR.Hidden = false;
            ccViewHR.Hidden = false;
            bccViewHR.Hidden = false;
            attachmentViewHR.Hidden = false;

            intentView.Hidden = !alwaysShowIntent;
            intentLabelHR.Hidden = !alwaysShowIntent;

            suppressLayout = true;
            toView.ConfigureView ();
            ccView.ConfigureView ();
            bccView.ConfigureView ();
            attachmentView.ConfigureView ();
            suppressLayout = false;

            if (animate) {
                LayoutView ();
            } else {
                LayoutWithoutAnimation ();
            }
        }

        protected void ConfigureSubjectEditView (bool animate)
        {
            // If ccView is hidden,leave it that way.
            toView.Hidden = false;
            toViewHR.Hidden = false;
            // ccView.Hidden = false;
            bccView.Hidden = true;
            bccViewHR.Hidden = true;

            toView.SetCompact (true, -1);
            ccView.SetCompact (true, -1);
            bccView.SetCompact (true, -1);
            attachmentView.Hidden = (calendarInviteIsSet ? true : false); 
            attachmentView.SetCompact (true);

            suppressLayout = true;
            toView.ConfigureView ();
            ccView.ConfigureView ();
            bccView.ConfigureView ();
            attachmentView.ConfigureView ();
            suppressLayout = false;

            alwaysShowIntent = true;
            intentView.Hidden = false;
            intentLabelHR.Hidden = false;

            if (animate) {
                LayoutView ();
            } else {
                LayoutWithoutAnimation ();
            }
        }

        protected void ConfigureBodyEditView (bool animate)
        {
            // this might be the place that we set up our initializaiton text
            toView.SetCompact (true, -1);

            toView.Hidden = false;
            ccView.Hidden = true;
            bccView.Hidden = true;
            attachmentView.Hidden = true;

            toViewHR.Hidden = false;
            ccViewHR.Hidden = true;
            bccViewHR.Hidden = true;
            attachmentViewHR.Hidden = true;

            intentView.Hidden = !alwaysShowIntent;
            intentLabelHR.Hidden = !alwaysShowIntent;

            suppressLayout = true;
            toView.ConfigureView ();
            ccView.ConfigureView ();
            bccView.ConfigureView ();
            attachmentView.ConfigureView ();
            suppressLayout = false;

            if (animate) {
                LayoutView ();
            } else {
                LayoutWithoutAnimation ();
            }
        }

        /// IUcAttachmentBlock delegate
        public void AttachmentBlockNeedsLayout (UcAttachmentBlock view)
        {
            if (suppressLayout) {
                return;
            }
            LayoutView ();
        }

        public void AddressBlockNeedsLayout (UcAddressBlock view)
        {
            if (suppressLayout) {
                return;
            }
            LayoutView ();
        }

        public void AddressBlockWillBecomeActive (UcAddressBlock view)
        {
            if (view == toView) {
                ConfigureToView (true);
            } else {
                ConfigureCcView (true);
            }
        }

        public void AddressBlockWillBecomeInactive (UcAddressBlock view)
        {
        }

        protected void LayoutView ()
        {
            if (suppressLayout) {
                return;
            }
            UIView.Animate (0.2, () => {
                LayoutWithoutAnimation ();
            });
        }

        protected void LayoutWithoutAnimation ()
        {
            toView.Layout ();
            ccView.Layout ();
            bccView.Layout ();
            attachmentView.Layout ();

            float yOffset = 0;

            AdjustY (toView, yOffset);
            AdjustY (toViewHR, yOffset + toView.Frame.Height);
            if (!toView.Hidden) {
                yOffset = toViewHR.Frame.Bottom;
            }

            AdjustY (ccView, yOffset);
            AdjustY (ccViewHR, yOffset + ccView.Frame.Height);
            if (!ccView.Hidden) {
                yOffset = ccViewHR.Frame.Bottom;

            }

            AdjustY (bccView, yOffset);
            AdjustY (bccViewHR, yOffset + bccView.Frame.Height);
            if (!bccView.Hidden) {
                yOffset = bccViewHR.Frame.Bottom;
            }

            CenterY (subjectLabel, LEFT_INDENT, yOffset, subjectLabel.Frame.Width, LINE_HEIGHT);

            var subjectFieldStart = subjectLabel.Frame.X + subjectLabel.Frame.Width;
            var subjectFieldWidth = View.Frame.Width - subjectField.Frame.X;
            CenterY (subjectField, subjectFieldStart, yOffset, subjectFieldWidth, LINE_HEIGHT);
            yOffset += LINE_HEIGHT;

            AdjustY (subjectLabelHR, yOffset);
            yOffset += subjectLabelHR.Frame.Height;

            // Intent subviews
            CenterY (intentLabel, LEFT_INDENT, 0, intentLabel.Frame.Width, LINE_HEIGHT);
   
            var intentDisplayStart = intentLabel.Frame.Right + 4;
            var intentDisplayWidth = View.Frame.Width - intentDisplayStart - 12 - RIGHT_INDENT;
            CenterY (intentDisplayLabel, intentDisplayStart, 0, intentDisplayWidth, LINE_HEIGHT);

            intentView.Frame = new RectangleF (0, yOffset, View.Frame.Width, LINE_HEIGHT);
            AdjustY (intentLabelHR, intentView.Frame.Bottom);

            if (!intentView.Hidden) {
                yOffset = intentLabelHR.Frame.Bottom;
            }

            if (!attachmentView.Hidden) {
                AdjustY (attachmentView, yOffset);
                yOffset += attachmentView.Frame.Height;
                AdjustY (attachmentViewHR, yOffset);
                yOffset += attachmentViewHR.Frame.Height;
            }

            scrollView.Frame = new RectangleF (0, 0, View.Frame.Width, View.Frame.Height - keyboardHeight);

            var contentFrame = new RectangleF (0, 0, View.Frame.Width, yOffset);
            contentView.Frame = contentFrame;

            ViewFramer.Create (bodyTextView).Y (contentFrame.Bottom);

            SetBodyAndScrollViewSize (bodyTextView);
        }

        protected void AdjustY (UIView view, float yOffset)
        {
            var frame = view.Frame;
            frame.Y = yOffset;
            view.Frame = frame;
        }

        protected void CenterY (UIView view, float x, float y, float width, float section_height)
        {
            var centeredY = y + (section_height / 2) - (view.Frame.Height / 2);
            view.Frame = new RectangleF (x, centeredY, width, view.Frame.Height);
        }

        private void OnKeyboardNotification (NSNotification notification)
        {
            if (IsViewLoaded) {
                //Check if the keyboard is becoming visible
                bool visible = notification.Name == UIKeyboard.WillShowNotification;
                //Start an animation, using values from the keyboard
                UIView.BeginAnimations ("AnimateForKeyboard");
                UIView.SetAnimationBeginsFromCurrentState (true);
                UIView.SetAnimationDuration (UIKeyboard.AnimationDurationFromNotification (notification));
                UIView.SetAnimationCurve ((UIViewAnimationCurve)UIKeyboard.AnimationCurveFromNotification (notification));
                //Pass the notification, calculating keyboard height, etc.
                bool landscape = InterfaceOrientation == UIInterfaceOrientation.LandscapeLeft || InterfaceOrientation == UIInterfaceOrientation.LandscapeRight;
                if (visible) {
                    var keyboardFrame = UIKeyboard.FrameEndFromNotification (notification);
                    OnKeyboardChanged (visible, landscape ? keyboardFrame.Width : keyboardFrame.Height);
                } else {
                    var keyboardFrame = UIKeyboard.FrameBeginFromNotification (notification);
                    OnKeyboardChanged (visible, landscape ? keyboardFrame.Width : keyboardFrame.Height);
                }
                //Commit the animation
                UIView.CommitAnimations (); 
            }
        }

        /// <summary>
        /// Override this method to apply custom logic when the keyboard is shown/hidden
        /// </summary>
        /// <param name='visible'>
        /// If the keyboard is visible
        /// </param>
        /// <param name='height'>
        /// Calculated height of the keyboard (width not generally needed here)
        /// </param>
        protected virtual void OnKeyboardChanged (bool visible, float height)
        {
            var newHeight = (visible ? height : 0);

            if (newHeight == keyboardHeight) {
                return;
            }
            keyboardHeight = newHeight;

            LayoutView ();
        }

        /// <summary>
        /// Requires iOS 7
        /// </summary>
        public static float AdjustToFittingHeight (UITextView textView)
        {
            if (textView == null) {
                return 0;
            }

            // Using simply ContentSize does not work on iOS7. The dimensions are calculated lazily.
            // Enforce the layout of the text container to get correct measurements.
            textView.LayoutManager.EnsureLayoutForTextContainer (textView.TextContainer);

            // Get container size from the layout manager.
            var containerSize = textView.LayoutManager.GetUsedRectForTextContainer (textView.TextContainer).Size;

            // Take insets into consideration.
            float height = (float)Math.Ceiling (containerSize.Height + textView.TextContainerInset.Top + textView.TextContainerInset.Bottom);

            // Adjust frame but only alter height.
            textView.Frame = new RectangleF (textView.Frame.X, textView.Frame.Y, textView.Frame.Width, height);

            // Return the height for convenient access.
            return height;
        }

        /// <summary>
        /// iOS 6 and before
        /// </summary>
        public static float OldAdjustToFittingHeight (UITextView textView)
        {
            if (textView == null) {
                return 0;
            }

            // Get the size that'll hold this text.
            var sz = textView.SizeThatFits (new SizeF (textView.Frame.Width, float.MaxValue));

            // Adjust frame but only alter height.
            textView.Frame = new RectangleF (textView.Frame.X, textView.Frame.Y, textView.Frame.Width, sz.Height);

            return sz.Height;
        }

        protected void SetBodyAndScrollViewSize (UITextView textView)
        {
            OldAdjustToFittingHeight (textView);

            if (!textView.Frame.Size.Equals (textView.ContentSize)) {
                textView.ContentSize = textView.Frame.Size;
            }
            var scrollViewContentSize = new SizeF (textView.ContentSize.Width, textView.Frame.Y + textView.Frame.Height);
            if (!scrollView.ContentSize.Equals (scrollViewContentSize)) {
                scrollView.ContentSize = scrollViewContentSize;
            }
        }

        /// <summary>
        /// Called when a key is pressed (or other changes) in body text view.
        /// CAREFUL:  Also called from Layout to set body and scrollview sizes. 
        /// </summary>
        protected void SelectionChanged (UITextView textView)
        {
            SetBodyAndScrollViewSize (textView);

            // We want to scroll the caret rect into view
            var caretRect = textView.GetCaretRectForPosition (textView.SelectedTextRange.Start);
            caretRect.Size = new SizeF (caretRect.Size.Width, caretRect.Size.Height + textView.TextContainerInset.Bottom);

            var targetRect = caretRect;
            targetRect.Y += textView.Frame.Y;
            scrollView.ScrollRectToVisible (targetRect, true);
        }

        public void AddressBlockClicked (UcAddressBlock view, string prefix, string segue)
        {
            NcEmailAddress.Kind kind = NcEmailAddress.Kind.Unknown;

            if (view == toView) {
                kind = NcEmailAddress.Kind.To;
            } else if (view == ccView) {
                kind = NcEmailAddress.Kind.Cc;
            } else if (view == bccView) {
                kind = NcEmailAddress.Kind.Bcc;
            } else {
                NcAssert.CaseError ();
            }
            var e = new NcEmailAddress (kind);
            e.action = NcEmailAddress.Action.create;
            e.address = prefix;
            PerformSegue (segue, new SegueHolder (e));
        }

        /// IUcAddressBlock delegate
        public void AddressBlockAutoCompleteContactClicked (UcAddressBlock view, string prefix)
        {
            AddressBlockClicked (view, prefix, "ComposeToContactChooser");
        }

        /// IUcAddressBlock delegate
        public void AddressBlockSearchContactClicked (UcAddressBlock view, string prefix)
        {
            AddressBlockClicked (view, prefix, "ComposeToContactSearch");
        }

        public void DismissINachoContactChooser (INachoContactChooser vc)
        {
            vc.Cleanup ();
            NavigationController.PopToViewController (this, true);
        }

        protected void ShowQuickResponses ()
        {
            switch (QRType) {
            case NcQuickResponse.QRTypeEnum.Compose:
            case NcQuickResponse.QRTypeEnum.Reply:
            case NcQuickResponse.QRTypeEnum.Forward:
                mcMessage.BodyId = McBody.InsertFile (account.Id, McAbstrFileDesc.BodyTypeEnum.PlainText_1, bodyTextView.Text).Id;
                break;
            case NcQuickResponse.QRTypeEnum.None:
                break;
            default:
                NcAssert.CaseError ("This type is not supported");
                break;
            }

            mcMessage.Subject = subjectField.Text;
            PerformSegue ("SegueToQuickResponse", this);
        }

        public void PopulateMessageFromQR (NcQuickResponse.QRTypeEnum whichType)
        {
            switch (whichType) {
            case NcQuickResponse.QRTypeEnum.Compose:
                alwaysShowIntent = true;
                subjectField.Text = mcMessage.Subject;
                bodyTextView.Text = McBody.GetContentsString (mcMessage.BodyId);
                break;
            case NcQuickResponse.QRTypeEnum.Reply:
                bodyTextView.Text = McBody.GetContentsString (mcMessage.BodyId);
                break;
            case NcQuickResponse.QRTypeEnum.Forward:
                bodyTextView.Text = McBody.GetContentsString (mcMessage.BodyId);
                break;
            default:
                break;
            }

            bodyTextView.BecomeFirstResponder ();
            if (bodyTextView.Text.Contains ("\n")) {
                bodyTextView.SelectedRange = new NSRange (bodyTextView.Text.IndexOf ("\n"), 0);
            }
        }

        public void SetCalendarInvite (McCalendar c)
        {
            this.calendarInviteItem = c;
            calendarInviteIsSet = true;
        }

        public void PopulateMessageFromSelectedIntent (MessageDeferralType intentDateTypeEnum)
        {
            intentDateType = intentDateTypeEnum;
            intentDisplayLabel.Text = NcMessageIntent.GetIntentString (intentDateTypeEnum, mcMessage);
        }

        public void SelectMessageIntent (NcMessageIntent.MessageIntent intent)
        {
            messageIntent.SetType (intent);
            messageIntent.SetMessageIntent (ref mcMessage);
            PopulateMessageFromSelectedIntent (MessageDeferralType.None);
        }

        /// IUcAttachmentBlock delegate
        public void PerformSegueForAttachmentBlock (string identifier, SegueHolder segueHolder)
        {
            PerformSegue (identifier, segueHolder);
        }

        /// IUcAttachmentBlock delegate
        public void DisplayAttachmentForAttachmentBlock (McAttachment attachment)
        {
            PlatformHelpers.DisplayAttachment (this, attachment);
        }

        /// IUcAttachmentBlock delegate
        public void PresentViewControllerForAttachmentBlock (UIViewController viewControllerToPresent, bool animated, NSAction completionHandler)
        {
            this.PresentViewController (viewControllerToPresent, animated, completionHandler);
        }


        /// <summary>
        /// INachoContactChooser callback
        /// </summary>
        public void UpdateEmailAddress (INachoContactChooser vc, NcEmailAddress address)
        {
            NcAssert.True (null != address);

            switch (address.kind) {
            case NcEmailAddress.Kind.To:
                toView.Append (address);
                break;
            case NcEmailAddress.Kind.Cc:
                ccView.Append (address);
                break;
            case NcEmailAddress.Kind.Bcc:
                bccView.Append (address);
                break;
            default:
                NcAssert.CaseError ();
                break;
            }
        }

        /// <summary>
        /// Callback
        /// </summary>
        public void DeleteEmailAddress (INachoContactChooser vc, NcEmailAddress address)
        {
            // Chooser returned an empty stirng; ignore it.
        }

        private bool OkToSend ()
        {
            // TODO Check if any large attachments will need to be downloaded.
            // Ask the user whether to send without the attachments or to wait
            // for them to be downloaded.

            if (0 == toView.AddressList.Count) {
                UIAlertView alert = new UIAlertView (
                                        "Hold on!", 
                                        "Please choose a contact to receive this message.", 
                                        null, 
                                        "OK"
                                    );
                alert.Show ();
                return false;
            }
            return true;
        }

        /// <summary>
        /// Backend is converting to mime.
        /// TODO: SendMessage should encode as mime or not.
        /// </summary>
        public void SendMessage ()
        {

            if (!calendarInviteIsSet) {
                var mimeMessage = new MimeMessage ();

                mimeMessage.From.Add (new MailboxAddress (Pretty.DisplayNameForAccount (account), account.EmailAddr));
                foreach (var view in new UcAddressBlock[] { toView, ccView, bccView }) {
                    foreach (var a in view.AddressList) {
                        var mailbox = a.ToMailboxAddress ();
                        if (null == mailbox) {
                            continue;
                        }
                        switch (a.kind) {
                        case NcEmailAddress.Kind.To:
                            mimeMessage.To.Add (mailbox);
                            break;
                        case NcEmailAddress.Kind.Cc:
                            mimeMessage.Cc.Add (mailbox);
                            break;
                        case NcEmailAddress.Kind.Bcc:
                            mimeMessage.Bcc.Add (mailbox);
                            break;
                        default:
                            NcAssert.CaseError ();
                            break;
                        }
                    }
                }
                mimeMessage.Subject = Pretty.SubjectString (subjectField.Text);

                if (McEmailMessage.IntentType.None != (McEmailMessage.IntentType)mcMessage.Intent) {
                    if (String.IsNullOrEmpty (mimeMessage.Subject)) {
                        mimeMessage.Subject = NcMessageIntent.GetIntentString (intentDateType, mcMessage);
                    } else {
                        mimeMessage.Subject = NcMessageIntent.GetIntentString (intentDateType, mcMessage) + " - " + mimeMessage.Subject;
                    }
                }

                mimeMessage.Date = System.DateTime.UtcNow;

                // TODO Check whether or not the back end supports SmartReply and SmartForward

            bool originalEmailIsEmbedded = true;
            string bodyText = bodyTextView.Text;
            if (!string.IsNullOrEmpty(initialQuotedText) && bodyText.EndsWith (initialQuotedText)) {
                // This is a reply or forward, and the user didn't changed the quoted text.
                // Strip the quoted text from the body of the message and instead have the
                // server add in the original message.
                originalEmailIsEmbedded = false;
                bodyText = bodyText.Remove (bodyText.Length - initialQuotedText.Length);
            }

                var body = new BodyBuilder ();

                body.TextBody = bodyText;

                foreach (var attachment in attachmentView.AttachmentList) {
                    body.Attachments.Add (attachment.GetFilePath ());
                }
                bool attachmentNeedsDownloading = false;
                if (IsForwardAction () && originalEmailIsEmbedded) {
                    // The user edited the body of the message being forwarded. That means the server won't
                    // automatically include the attachments from the forwarded message (if any).  That needs
                    // to be done explicitly.  If all of the necessary attachments are available, go ahead and
                    // add them to the message now.  If any of the attachments need to be downloaded, then
                    // wait until later to add them.
                    var originalAttachments = McAttachment.QueryByItemId (referencedMessage);
                    foreach (var attachment in originalAttachments) {
                        if (McAbstrFileDesc.FilePresenceEnum.Complete != attachment.FilePresence) {
                            attachmentNeedsDownloading = true;
                            break;
                        }
                    }
                    if (!attachmentNeedsDownloading) {
                        foreach (var attachment in originalAttachments) {
                            body.Attachments.Add (attachment.GetFilePath ());
                        }
                    }
                }
                
                mimeMessage.Body = body.ToMessageBody ();
                var messageToSend = MimeHelpers.AddToDb (account.Id, mimeMessage);
                messageToSend.Intent = this.mcMessage.Intent;
                messageToSend.IntentDate = this.mcMessage.IntentDate;
                messageToSend.Update ();
                if (IsForwardOrReplyAction ()) {
                    messageToSend.ReferencedEmailId = referencedMessage.Id;
                    messageToSend.ReferencedBodyIsIncluded = originalEmailIsEmbedded;
                    messageToSend.ReferencedIsForward = IsForwardAction ();
                    messageToSend.WaitingForAttachmentsToDownload = attachmentNeedsDownloading;
                    messageToSend.Update ();
                }

                bool messageSent = false;
                if (IsForwardOrReplyAction ()) {
                    var folders = McFolder.QueryByFolderEntryId<McEmailMessage> (referencedMessage.AccountId, referencedMessage.Id);
                    if (folders.Count == 0) {
                        Log.Error (Log.LOG_UI, "The message being forwarded or replied to is not owned by any folder. It will be sent as a regular outgoing message. Message: {0}", referencedMessage.ToString ());
                        // Fall through and send it as a regular message.
                    } else {
                        if (folders.Count > 1) {
                            Log.Warn (Log.LOG_UI, "The message being forwarded or replied to is owned by {0} folders. One of the folders will be picked at random as the official owner when sending the message. Message: {0}", folders.Count, referencedMessage.ToString ());
                        }
                        int folderId = folders [0].Id;
                        if (IsForwardAction ()) {
                            NachoCore.BackEnd.Instance.ForwardEmailCmd (messageToSend.AccountId, messageToSend.Id, referencedMessage.Id, folderId, originalEmailIsEmbedded);
                        } else {
                            NachoCore.BackEnd.Instance.ReplyEmailCmd (messageToSend.AccountId, messageToSend.Id, referencedMessage.Id, folderId, originalEmailIsEmbedded);
                        }
                        messageSent = true;
                    }
                }
                if (!messageSent) {
                    // A new outgoing message.  Or a forward/reply that has problems.
                    NachoCore.BackEnd.Instance.SendEmailCmd (messageToSend.AccountId, messageToSend.Id);
                    // TODO: Subtle ugliness. Id is passed to BE, ref-count is ++ in the DB.
                    // The object here still has ref-count of 0, so interlock is lost, and delete really happens in the DB.
                    // BE goes to reference the object later on, and it is missing.
                    messageToSend = McEmailMessage.QueryById<McEmailMessage> (messageToSend.Id);
                    messageToSend.Delete ();
                }
            } else {

                // Create new attendees from addresses in To
                var mailList = new List<MailboxAddress> ();

                foreach (var view in new UcAddressBlock[] { toView, ccView, bccView }) {
                    foreach (var a in view.AddressList) {
                        var mailbox = a.ToMailboxAddress ();
                        if (null == mailbox) {
                            continue;
                        }

//                        var name = mailbox.Name;
//                        if (String.IsNullOrEmpty (name)) {
//                            name = mailbox.Address;
//                        }
//                        
//                        var attendee = new McAttendee ();
//                        attendee.AccountId = account.Id;
//                        attendee.Name = name;
//                        attendee.Email = mailbox.Address;
//                        attendee.AttendeeType = NcAttendeeType.Required;
//                        attendee.AttendeeTypeIsSet = true;
//                        calendarInviteItem.attendees.Add (attendee);
                        mailList.Add (mailbox);
                    }
                }

                // Update calendar item
                calendarInviteItem.Update ();
                BackEnd.Instance.UpdateCalCmd (account.Id, calendarInviteItem.Id);
                NcApplication.Instance.InvokeStatusIndEvent (new StatusIndEventArgs () { 
                    Status = NachoCore.Utils.NcResult.Info (NcResult.SubKindEnum.Info_CalendarSetChanged),
                    Account = NachoCore.Model.ConstMcAccount.NotAccountSpecific,
                });

                // Create mime
                var iCalPart = CalendarHelper.iCalToMimePart (account, calendarInviteItem);

                StringBuilder bodyText = new StringBuilder ();
                bodyText.Append (bodyTextView.Text).Append ("\n\n").Append (FormatBasicHeadersForCalendarForward (calendarInviteItem, account.EmailAddr)).Append (calendarInviteItem.Description ?? "");
                var mimeBody = CalendarHelper.CreateMime (bodyText.ToString (), iCalPart, calendarInviteItem.attachments);

                CalendarHelper.SendInvites (account, calendarInviteItem, Pretty.SubjectString (subjectField.Text), null, mimeBody, mailList);

            }
        }

        // TODO: Put in pretty
        protected string CreateInitialSubjectLine ()
        {
            if (IsSendAction ()) {
                return ""; // Creating a message
            }

            var Subject = "";
            if (null != referencedMessage.Subject) {
                Subject = referencedMessage.Subject;
            }

            if (IsReplyAction ()) {
                if (Subject.StartsWith ("Re:")) {
                    return Subject;
                }
                return "Re: " + Subject;
            }
            if (IsForwardAction ()) {
                return "Fwd: " + Subject;
            }
            return "";
        }

        /// <summary>
        /// Reply, ReplyAll, Forward
        /// FIXME:  Wait for full text to arrive!
        /// </summary>
        void InitializeMessageForAction ()
        {
            if (IsReplyAction ()) {
                toView.Append (new NcEmailAddress (NcEmailAddress.Kind.To, referencedMessage.From));
            }
            if (Action.ReplyAll == action) {
                // Add the To list to the CC list
                if (null != referencedMessage.To) {
                    string[] ToList = referencedMessage.To.Split (new Char [] { ',' });
                    if (null != ToList) {
                        foreach (var a in ToList) {
                            ccView.Append (new NcEmailAddress (NcEmailAddress.Kind.Cc, a));
                        }
                    }
                }
                // And keep the existing CC list
                if (null != referencedMessage.Cc) {
                    string[] ccList = referencedMessage.Cc.Split (new Char [] { ',' });
                    if (null != ccList) {
                        foreach (var a in ccList) {
                            ccView.Append (new NcEmailAddress (NcEmailAddress.Kind.Cc, a));
                        }
                    }
                }
            }

            subjectField.Text = CreateInitialSubjectLine ();
            if (!string.IsNullOrEmpty (subjectField.Text)) {
                alwaysShowIntent = true;
            }

            // TODO: Setup message id, etc etc.

            // Populate the body of the outgoing message with the quoted text from the message being acted on.
            // Right now this is identical for forward and reply.  But that might change as the behavior is refined.
            initialQuotedText = MimeHelpers.ExtractTextPart (referencedMessage);
            string headersText = FormatBasicHeaders (referencedMessage);
            bodyTextView.Text = "\n\n" + headersText + initialQuotedText;
        }

        // Build up the text for the header part of the message being forwarded or replied to.
        private string FormatBasicHeaders (McEmailMessage message)
        {
            StringBuilder result = new StringBuilder ();
            result.Append ("-------------------\n");
            result.Append ("From: ").Append (message.From ?? "").Append ("\n");
            if (message.To != null && message.To.Length > 0) {
                result.Append ("To: ").Append (message.To).Append ("\n");
            }
            if (message.Cc != null && message.Cc.Length > 0) {
                result.Append ("Cc: ").Append (message.Cc).Append ("\n");
            }
            result.Append ("Subject: ").Append (message.Subject ?? "").Append ("\n");
            result.Append ("Date: ").Append (Pretty.UniversalFullDateTimeString (message.DateReceived));
            result.Append ("\n\n");
            return result.ToString ();
        }

        // Build up the text for the header part of the message being forwarded or replied to.
        private string FormatBasicHeadersForCalendarForward (McCalendar calendar, string recipient)
        {
            StringBuilder result = new StringBuilder ();
            result.Append ("-------------------\n");
            result.Append ("Organizer: ").Append (calendar.OrganizerName ?? calendar.OrganizerEmail ?? "").Append ("\n");
            result.Append ("To: ").Append (recipient).Append ("\n");
            result.Append ("Subject: ").Append (calendar.Subject ?? "").Append ("\n");
            result.Append ("When: ").Append (Pretty.FullDateYearString (calendar.StartTime)).Append ("\n");
            result.Append ("Where: ").Append (calendar.Location ?? "").Append ("\n");
            result.Append ("\n\n");
            return result.ToString ();
        }

        /// <summary>
        /// INachoFileChooserParent delegate
        /// </summary>
        public void SelectFile (INachoFileChooser vc, McAbstrObject obj)
        {
            var a = obj as McAttachment;
            if (null != a) {
                attachmentView.Append (a);
                this.DismissViewController (true, null);
                return;
            }

            var file = obj as McDocument;
            if (null != file) {
                var attachment = McAttachment.InsertSaveStart (account.Id);
                attachment.SetDisplayName (file.DisplayName);
                attachment.IsInline = true;
                attachment.UpdateFileCopy (file.GetFilePath ());
                attachmentView.Append (attachment);
                this.DismissViewController (true, null);
                return;
            }

            var note = obj as McNote;
            if (null != note) {
                var attachment = McAttachment.InsertSaveStart (account.Id);
                attachment.SetDisplayName (note.DisplayName + ".txt");
                attachment.IsInline = true;
                attachment.UpdateData (note.noteContent);
                attachmentView.Append (attachment);
                this.DismissViewController (true, null);
                return;
            }

            NcAssert.CaseError ();
        }

        public void DateSelected (MessageDeferralType request, McEmailMessageThread thread, DateTime selectedDate)
        {
            messageIntent.SetMessageIntentDate (ref mcMessage, selectedDate);
            PopulateMessageFromSelectedIntent (request);
        }

        public void DismissChildDateController (INachoDateController vc)
        {
            vc.Setup (null, null, DateControllerType.None);
            vc.DismissDateController (false, null);
        }

        /// <summary>
        /// INachoFileChooserParent delegate
        /// </summary>
        public void DismissChildFileChooser (INachoFileChooser vc)
        {
            vc.DismissFileChooser (true, null);
        }

        /// <summary>
        /// INachoFileChooserParent delegate
        /// </summary>
        public void Append (McAttachment attachment)
        {
            attachmentView.Append (attachment);
        }

        /// <summary>
        /// INachoFileChooserParent delegate
        /// </summary>
        public void DismissPhotoPicker ()
        {
            this.DismissViewController (true, null);
        }

        public void SetAction (McEmailMessageThread thread, string actionString)
        {
            if (null != thread) {
                referencedMessage = thread.SingleMessageSpecialCase ();
            }
            if (null == actionString) {
                action = Action.Send;
            } else if (REPLY_ACTION.Equals (actionString)) {
                action = Action.Reply;
            } else if (REPLY_ALL_ACTION.Equals (actionString)) {
                action = Action.ReplyAll;
            } else if (FORWARD_ACTION.Equals (actionString)) {
                action = Action.Forward;
            } else {
                NcAssert.CaseError (String.Format ("Unexpected value for message action: {0}", actionString));
            }
            if (Action.Send != action) {
                NcAssert.NotNull (referencedMessage, String.Format ("A null message was passed to MessageComposeViewController for an action of {0}", actionString));
            }
        }

        protected bool IsSendAction ()
        {
            return Action.Send == action;
        }

        protected bool IsForwardOrReplyAction ()
        {
            return Action.Send != action;
        }

        // Reply or ReplyAll.  In almost all cases the two are treated the same.  There is only one case where they are different.
        protected bool IsReplyAction ()
        {
            return Action.Reply == action || Action.ReplyAll == action;
        }

        protected bool IsForwardAction ()
        {
            return Action.Forward == action;
        }
    }
}
