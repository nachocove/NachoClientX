// This file has been autogenerated from a class added in the UI designer.

using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using CoreGraphics;
using Foundation;
using UIKit;

using MimeKit;

using NachoCore;
using NachoPlatform;
using NachoCore.Brain;
using NachoCore.Model;
using NachoCore.Utils;

using WebKit;

namespace NachoClient.iOS
{
    
    public interface MessageComposeViewDelegate {

        void MessageComposeViewDidBeginSend (MessageComposeViewController vc);
        void MessageComposeViewDidSaveDraft (MessageComposeViewController vc);
        void MessageComposeViewDidCancel (MessageComposeViewController vc);

    }

    public partial class MessageComposeViewController : NcUIViewController,
        // IWKNavigationDelegate,
        // IWKScriptMessageHandler,
        IUIWebViewDelegate,
        IUIScrollViewDelegate,
        MessageComposeHeaderViewDelegate,
        QuickResponseViewControllerDelegate,
        INachoIntentChooserParent,
        INachoDateControllerParent,
        INachoFileChooserParent,
        INachoContactChooserDelegate,
        MessageComposerDelegate,
        NcWebViewMessageHandler
    {

        #region Properties

        public MessageComposeViewDelegate ComposeDelegate;
        public bool StartWithQuickResponse;
        public readonly MessageComposer Composer;
        CompoundScrollView ScrollView;
        MessageComposeHeaderView HeaderView;
        UIWebView WebView;
        NcUIBarButtonItem CloseButton;
        NcUIBarButtonItem SendButton;
        NcUIBarButtonItem QuickResponseButton;
        UIAlertController CloseAlertController;
        UIAlertController SubjectAlertController;
        UIAlertController SizeAlertController;
        bool HasShownOnce;
        UIStoryboard mainStorybaord;
        UIStoryboard MainStoryboard {
            get {
                if (mainStorybaord == null) {
                    mainStorybaord = UIStoryboard.FromName ("MainStoryboard_iPhone", null);
                }
                return mainStorybaord;
            }

        }

        NSObject BackgroundNotification;
        NSObject ContentSizeCategoryChangedNotification;
        string ContentHtml;
        bool IsWebViewLoaded = false;
        List<string> JavaScriptQueue;
        bool MakeWebViewFirstResponderOnLoad = false;

        #endregion

        #region Constructors

        public MessageComposeViewController () : base ()
        {
            Composer = new MessageComposer (NcApplication.Instance.Account);
            Composer.Delegate = this;
            JavaScriptQueue = new List<string> ();
        }

        #endregion

        #region Presenters

        public void Present (Action completionHandler = null)
        {
            var window = UIApplication.SharedApplication.Delegate.GetWindow ();
            var navigationController = new UINavigationController (this);
            NachoClient.Util.ConfigureNavBar (false, navigationController);
            window.RootViewController.PresentViewController (navigationController, true, completionHandler);
        }

        #endregion

        #region View Lifecycle

        public override void ViewDidLoad ()
        {
            base.ViewDidLoad ();

            View.BackgroundColor = UIColor.White;

            // Nav bar
            CloseButton = new NcUIBarButtonItem ();
            Util.SetAutomaticImageForButton (CloseButton, "icn-close");
            CloseButton.AccessibilityLabel = "Close";
            CloseButton.Clicked += Close;

            SendButton = new NcUIBarButtonItem ();
            Util.SetAutomaticImageForButton (SendButton, "icn-send");
            SendButton.AccessibilityLabel = "Send";
            SendButton.Clicked += Send;

            QuickResponseButton = new NcUIBarButtonItem ();
            Util.SetAutomaticImageForButton (QuickResponseButton, "contact-quickemail");
            QuickResponseButton.AccessibilityLabel = "Quick response";
            QuickResponseButton.Clicked += QuickReply;

            NavigationItem.LeftBarButtonItem = CloseButton;
            NavigationItem.RightBarButtonItems = new UIBarButtonItem[] {
                SendButton,
                QuickResponseButton,
            };

            // Content Area
            ScrollView = new CompoundScrollView (View.Bounds);
            ScrollView.AutoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight;
            ScrollView.AlwaysBounceVertical = true;
            ScrollView.Delegate = this;

            HeaderView = new MessageComposeHeaderView (ScrollView.Bounds);
            HeaderView.Frame = new CGRect (0.0, 0.0, ScrollView.Bounds.Width, HeaderView.PreferredHeight);
            HeaderView.HeaderDelegate = this;
            HeaderView.AttachmentsAllowed = Composer.RelatedCalendarItem == null;
            // Was originally going to use WKWebView, but it won't load file:/// URLs on device (will in simulator, though).
            // Might as well keep the code around for reference if we ever want to make the switch
            // var config = new WKWebViewConfiguration ();
            // config.SuppressesIncrementalRendering = true;
            // config.UserContentController.AddScriptMessageHandler (this, "nachoCompose");
            // config.UserContentController.AddScriptMessageHandler (this, "nacho");
            // WebView = new WKWebView (ScrollView.Bounds, config);
            // WebView.NavigationDelegate = this;
            WebView = new UIWebView (View.Bounds);
            WebView.SuppressesIncrementalRendering = true;
            WebView.Delegate = this;
            WebView.NcHijack ();
            WebView.KeyboardDisplayRequiresUserAction = false;
            NcWebViewMessageProtocol.AddHandler (this, "nachoCompose");
            NcWebViewMessageProtocol.AddHandler (this, "nacho");

            ScrollView.AddCompoundView (HeaderView);
            ScrollView.AddCompoundView (WebView);
            View.AddSubview (ScrollView);

            NcWebViewMessageProtocol.Register ();
        }

        public override void ViewWillAppear (bool animated)
        {
            base.ViewWillAppear (animated);
            RegisterForNotifications ();
            if (!HasShownOnce) {
                Composer.StartPreparingMessage ();
                UpdateHeaderView ();
                UpdateSendEnabled ();
                if (StartWithQuickResponse) {
                    ShowQuickResponses ();
                } else {
                    if (!Composer.HasRecipient) {
                        HeaderView.ToView.SetEditFieldAsFirstResponder ();
                    } else if (String.IsNullOrEmpty (Composer.Message.Subject)) {
                        HeaderView.SubjectField.BecomeFirstResponder ();
                    } else if (IsWebViewLoaded) {
                        MakeWebViewFirstResponder ();
                    } else {
                        MakeWebViewFirstResponderOnLoad = true;
                    }
                }
                HasShownOnce = true;
            }

        }

        public override void ViewDidAppear (bool animated)
        {
            base.ViewDidAppear (animated);
        }

        public override void ViewWillDisappear (bool animated)
        {
            base.ViewWillDisappear (animated);
            UnregisterNotifications ();
        }

        public override void ViewDidDisappear (bool animated)
        {
            base.ViewDidDisappear (animated);
        }

        #endregion

        #region Layout

        private void UpdateScrollViewSize ()
        {
            ScrollView.DetermineContentSize ();
        }

        private void LayoutScrollView ()
        {
            UpdateScrollViewSize ();
            ScrollView.SetNeedsLayout ();
            ScrollView.LayoutIfNeeded ();
        }

        public void MessageComposeHeaderViewDidChangeHeight (MessageComposeHeaderView view)
        {
            LayoutScrollView ();
        }

        protected override void OnKeyboardChanged ()
        {
            var frame = View.Bounds;
            frame.Height = frame.Height - keyboardHeight;
            ScrollView.Frame = frame;
            ScrollView.SetNeedsLayout ();
            ScrollView.LayoutIfNeeded ();
        }

        #endregion

        #region User Actions - Navbar

        // User hitting the send button
        public void Send (object sender, EventArgs e)
        {
            View.EndEditing (true);
            if (String.IsNullOrWhiteSpace (Composer.Message.Subject)) {
                SubjectAlertController = UIAlertController.Create ("Empty Subject", "This message does not have a subject.  How would you like to proceed?", UIAlertControllerStyle.Alert);
                SubjectAlertController.AddAction (UIAlertAction.Create ("Send Anyway", UIAlertActionStyle.Default, SendWithoutSubject));
                SubjectAlertController.AddAction (UIAlertAction.Create ("Add Subject", UIAlertActionStyle.Default, AddSubject));
                SubjectAlertController.AddAction (UIAlertAction.Create ("Cancel", UIAlertActionStyle.Cancel, (UIAlertAction obj) => { SubjectAlertController = null; }));
                PresentViewController (SubjectAlertController, true, null);
            } else {
                CheckSizeBeforeSending ();
            }
        }

        void SendWithoutSubject (UIAlertAction obj)
        {
            SubjectAlertController = null;
            CheckSizeBeforeSending ();
        }

        void AddSubject (UIAlertAction obj)
        {
            SubjectAlertController = null;
            HeaderView.SubjectField.BecomeFirstResponder ();
        }

        void CheckSizeBeforeSending ()
        {
            ContentHtml = GetHtmlContent ();
            Composer.Save (ContentHtml);
            if (Composer.IsOversize) {
                if (Composer.CanResize) {
                    SizeAlertController = UIAlertController.Create ("Large Message", String.Format ("This message is {0}.  You can make it smaller by sizing down the attached images.", Pretty.PrettyFileSize(Composer.MessageSize)), UIAlertControllerStyle.Alert);
                    SizeAlertController.AddAction (UIAlertAction.Create (String.Format ("Small Images ({0})", Pretty.PrettyFileSize(Composer.EstimatedSmallSize)), UIAlertActionStyle.Default, ResizeImagesSmall));
                    SizeAlertController.AddAction (UIAlertAction.Create (String.Format ("Medium Images ({0})", Pretty.PrettyFileSize(Composer.EstimatedMediumSize)), UIAlertActionStyle.Default, ResizeImagesMedium));
                    SizeAlertController.AddAction (UIAlertAction.Create (String.Format ("Large Images ({0})", Pretty.PrettyFileSize(Composer.EstimatedLargeSize)), UIAlertActionStyle.Default, ResizeImagesLarge));
                    SizeAlertController.AddAction (UIAlertAction.Create (String.Format ("Actual Size ({0})", Pretty.PrettyFileSize(Composer.MessageSize)), UIAlertActionStyle.Default, AcknowlegeSizeWarning));
                    SizeAlertController.AddAction (UIAlertAction.Create ("Cancel", UIAlertActionStyle.Cancel, (UIAlertAction obj) => { SizeAlertController = null; }));
                    PresentViewController (SizeAlertController, true, null);
                } else {
                    SizeAlertController = UIAlertController.Create ("Large Message", String.Format ("This message is {0}", Pretty.PrettyFileSize(Composer.MessageSize)), UIAlertControllerStyle.Alert);
                    SizeAlertController.AddAction (UIAlertAction.Create ("Send Anyway", UIAlertActionStyle.Default, AcknowlegeSizeWarning));
                    SizeAlertController.AddAction (UIAlertAction.Create ("Cancel", UIAlertActionStyle.Cancel, (UIAlertAction obj) => { SizeAlertController = null; }));
                    PresentViewController (SizeAlertController, true, null);
                }
            } else {
                Send ();
            }
        }

        void AcknowlegeSizeWarning (UIAlertAction obj)
        {
            SizeAlertController = null;
            Send ();
        }

        void ResizeImagesLarge (UIAlertAction obj)
        {
            SizeAlertController = null;
            ResizeImagesAndSend (Composer.LargeImageLengths);
        }

        void ResizeImagesMedium (UIAlertAction obj)
        {
            SizeAlertController = null;
            ResizeImagesAndSend (Composer.MediumImageLengths);
        }

        void ResizeImagesSmall (UIAlertAction obj)
        {
            SizeAlertController = null;
            ResizeImagesAndSend (Composer.SmallImageLengths);
        }

        void ResizeImagesAndSend (Tuple<float, float> lengths)
        {
            Composer.ResizeImages (lengths);
            Composer.Save (ContentHtml);
            Send ();
        }

        void Send ()
        {
            Composer.Send ();
            if (ComposeDelegate != null) {
                ComposeDelegate.MessageComposeViewDidBeginSend (this);
            }
            DismissViewController (true, null);
        }

        // User hitting the quick reply button
        public void QuickReply (object sender, EventArgs e)
        {
            View.EndEditing (true);
            ShowQuickResponses ();
        }

        // User hitting the close button
        public void Close (object sender, EventArgs e)
        {
            View.EndEditing (true);
            CloseAlertController = UIAlertController.Create (null, null, UIAlertControllerStyle.ActionSheet);
            CloseAlertController.AddAction (UIAlertAction.Create ("Discard Draft", UIAlertActionStyle.Destructive, Discard));
            CloseAlertController.AddAction (UIAlertAction.Create ("Save Draft", UIAlertActionStyle.Default, Save));
            CloseAlertController.AddAction (UIAlertAction.Create ("Cancel", UIAlertActionStyle.Cancel, (UIAlertAction obj) => { CloseAlertController = null; }));
            PresentViewController (CloseAlertController, true, null);
        }

        // User opting to discard while closing
        public void Discard (UIAlertAction obj)
        {
            CloseAlertController = null;
            Composer.Message.Delete ();
            if (ComposeDelegate != null) {
                ComposeDelegate.MessageComposeViewDidCancel (this);
            }
            DismissViewController (true, null);
        }

        // User opting to save while closing
        public void Save (UIAlertAction obj)
        {
            CloseAlertController = null;
            var html = GetHtmlContent ();
            Composer.Save (html);
            if (ComposeDelegate != null) {
                ComposeDelegate.MessageComposeViewDidSaveDraft (this);
            }
            DismissViewController (true, null);
        }

        // User selecting a quick response
        public void QuickResponseViewDidSelectResponse (QuickResponseViewController vc, NcQuickResponse.QRTypeEnum whatType, NcQuickResponse.QuickResponse response, McEmailMessage.IntentType intentType)
        {
            if (whatType == NcQuickResponse.QRTypeEnum.Compose) {
                Composer.Message.Subject = response.subject;
                UpdateHeaderSubjectView ();
            }
            if (Composer.IsMessagePrepared) {
                var javascriptString = JavaScriptEscapedString (response.body + Composer.SignatureText());
                EvaluateJavaScript (String.Format ("Editor.defaultEditor.replaceUserText({0});", javascriptString));
            } else {
                Composer.InitialText = response.body;
            }
            // TODO: show the intent field if hidden
            Composer.Message.Intent = intentType;
            Composer.Message.IntentDate = DateTime.MinValue;
            Composer.Message.IntentDateType = MessageDeferralType.None;
            UpdateHeaderIntentView ();
        }

        #endregion

        #region User Actions - Header

        // User selecting + button in To/CC/BCC field
        public void MessageComposeHeaderViewDidSelectContactChooser (MessageComposeHeaderView view, NcEmailAddress address)
        {
            ContactChooserViewController chooserController = MainStoryboard.InstantiateViewController ("ContactChooserViewController") as ContactChooserViewController;
            chooserController.SetOwner (this, Composer.Account, address, NachoContactType.EmailRequired);
            FadeCustomSegue.Transition (this, chooserController);
        }

        // User starting to type in To/CC/BCC field
        public void MessageComposeHeaderViewDidSelectContactSearch (MessageComposeHeaderView view, NcEmailAddress address)
        {
            ContactSearchViewController searchController = MainStoryboard.InstantiateViewController ("ContactSearchViewController") as ContactSearchViewController;
            searchController.SetOwner (this, Composer.Account, address, NachoContactType.EmailRequired);
            FadeCustomSegue.Transition (this, searchController);
        }

        // User selecting contact for To/CC/BCC field
        public void UpdateEmailAddress (INachoContactChooser vc, NcEmailAddress address)
        {
            if (address.kind == NcEmailAddress.Kind.To) {
                HeaderView.ToView.Append (address);
                Composer.Message.To = EmailHelper.AddressStringFromList (HeaderView.ToView.AddressList);
            } else if (address.kind == NcEmailAddress.Kind.Cc) {
                HeaderView.CcView.Append (address);
                Composer.Message.Cc = EmailHelper.AddressStringFromList (HeaderView.CcView.AddressList);
            } else if (address.kind == NcEmailAddress.Kind.Bcc) {
                HeaderView.BccView.Append (address);
                Composer.Message.Bcc = EmailHelper.AddressStringFromList (HeaderView.BccView.AddressList);
            } else {
                NcAssert.CaseError ();
            }
            UpdateSendEnabled ();
        }

        public void MessageComposeHeaderViewDidRemoveAddress (MessageComposeHeaderView view, NcEmailAddress address)
        {
            
            if (address.kind == NcEmailAddress.Kind.To) {
                Composer.Message.To = EmailHelper.AddressStringFromList (HeaderView.ToView.AddressList);
            } else if (address.kind == NcEmailAddress.Kind.Cc) {
                Composer.Message.Cc = EmailHelper.AddressStringFromList (HeaderView.CcView.AddressList);
            } else if (address.kind == NcEmailAddress.Kind.Bcc) {
                Composer.Message.Bcc = EmailHelper.AddressStringFromList (HeaderView.BccView.AddressList);
            } else {
                NcAssert.CaseError ();
            }
            UpdateSendEnabled ();
        }

        // ??
        // I think this is when the user starts typing an email adderess and then clears it.
        // Since we don't change anything when they start typing, there's nothing to change if the clear.
        public void DeleteEmailAddress (INachoContactChooser vc, NcEmailAddress address)
        {
            // old implementation did nothing
        }

        // User changing the subject
        public void MessageComposeHeaderViewDidChangeSubject (MessageComposeHeaderView view, string subject)
        {
            Composer.Message.Subject = subject;
        }

        // User tapping the intent field 
        public void MessageComposeHeaderViewDidSelectIntentField (MessageComposeHeaderView view)
        {
            IntentSelectionViewController intentController = MainStoryboard.InstantiateViewController ("IntentSelectionViewController") as IntentSelectionViewController;
            intentController.ModalTransitionStyle = UIModalTransitionStyle.CrossDissolve;
            intentController.SetOwner (this);
            intentController.SetDateControllerOwner (this);
            PresentViewController (intentController, true, null);
        }

        // User selecting an intent
        public void SelectMessageIntent (NcMessageIntent.MessageIntent intent)
        {
            Composer.Message.Intent = intent.type;
            Composer.Message.IntentDateType = MessageDeferralType.None;
            Composer.Message.IntentDate = DateTime.MinValue;
            UpdateHeaderIntentView ();
        }

        // User selecting a date for the intent
        public void DateSelected (NcMessageDeferral.MessageDateType type, MessageDeferralType request, McEmailMessageThread thread, DateTime selectedDate)
        {
            Composer.Message.IntentDateType = request;
            Composer.Message.IntentDate = selectedDate;
            UpdateHeaderIntentView ();
        }
            
        // User tapping on add attachment
        public void MessageComposeHeaderViewDidSelectAddAttachment (MessageComposeHeaderView view)
        {
            AddAttachmentViewController attachmentViewController = MainStoryboard.InstantiateViewController ("AddAttachmentViewController") as AddAttachmentViewController;
            attachmentViewController.ModalTransitionStyle = UIModalTransitionStyle.CrossDissolve;
            attachmentViewController.SetOwner (this, Composer.Account);
            PresentViewController (attachmentViewController, true, null);
        }

        // User tapping on a specific attachment to display
        public void MessageComposeHeaderViewDidSelectAttachment (MessageComposeHeaderView view, McAttachment attachment)
        {
            PlatformHelpers.DisplayAttachment (this, attachment);
        }

        // User picking a file as an attachment
        public void SelectFile (INachoFileChooser vc, McAbstrObject obj)
        {
            var attachment = obj as McAttachment;
            if (attachment != null) {
                attachment = AttachmentHelper.CopyAttachment (attachment);
            }else{
                var file = obj as McDocument;
                if (file != null) {
                    attachment = McAttachment.InsertSaveStart (Composer.Account.Id);
                    attachment.SetDisplayName (file.DisplayName);
                    attachment.UpdateFileCopy (file.GetFilePath ());
                } else {
                    var note = obj as McNote;
                    if (note != null) {
                        attachment = McAttachment.InsertSaveStart (Composer.Account.Id);
                        attachment.SetDisplayName (note.DisplayName + ".txt");
                        attachment.UpdateData (note.noteContent);
                    }
                }
            }

            if (attachment != null) {
                attachment.ItemId = Composer.Message.Id;
                attachment.ClassCode = Composer.Message.GetClassCode ();
                attachment.Update ();
                HeaderView.AttachmentsView.Append (attachment);
                this.DismissViewController (true, null);
            } else {
                NcAssert.CaseError ();
            }

        }

        // User deleting an attachment
        public void MessageComposeHeaderViewDidRemoveAttachment (MessageComposeHeaderView view, McAttachment attachment)
        {
            attachment.Delete ();
        }

        // User adding an attachment from media browser
        public void Append (McAttachment attachment)
        {
            attachment.ItemId = Composer.Message.Id;
            attachment.ClassCode = Composer.Message.GetClassCode ();
            attachment.Update ();
            HeaderView.AttachmentsView.Append (attachment);
        }

        public void AttachmentUpdated (McAttachment attachment)
        {
            HeaderView.AttachmentsView.UpdateAttachment (attachment);
        }

        // Not really a direct user action, but caused by the user selecting a date for the intent
        public void DismissChildDateController (INachoDateController vc)
        {
            // Basically, once the intent date view controller is dismissed, we need to dismiss the intent controller
            DismissViewController (false, null);
        }

        // Not really a direct user action, but caused by the user selecting a date for the intent
        public void DismissChildFileChooser (INachoFileChooser vc)
        {
            DismissViewController (true, null);
        }

        // Not really a direct user action, but caused by the user selecting a date for the intent
        public void DismissPhotoPicker ()
        {
            DismissViewController (true, null);
        }

        // Not really a direct user action, but caused by the user selecting a contact
        public void DismissINachoContactChooser (INachoContactChooser vc)
        {
            // The contact chooser was pushed on the nav stack, rather than shown as a modal.
            // So we need to pop it from the stack
            vc.Cleanup ();
            NavigationController.PopViewController (true);
        }

        #endregion

        #region Message Preparation

        public void MessageComposerDidCompletePreparation (MessageComposer composer)
        {
            DisplayMessageBody ();
        }

        public PlatformImage ImageForMessageComposerAttachment (MessageComposer composer, McAttachment attachment)
        {
            return ImageiOS.FromPath (attachment.GetFilePath ());
        }

        void DisplayMessageBody ()
        {
            if (Composer.Bundle != null) {
                if (Composer.Bundle.FullHtmlUrl != null) {
                    var url = new NSUrl (Composer.Bundle.FullHtmlUrl.AbsoluteUri);
                    // Here's how WKWebView would work
                    // if (url.Scheme.ToLowerInvariant().Equals("file")){
                    //    var selector = new ObjCRuntime.Selector ("loadFileURL:allowingReadAccessToURL:");
                    //     if (WebView.RespondsToSelector (selector)) {
                    //         var baseUrl = new NSUrl (Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments));
                    //         WebView.PerformSelector (selector, url, baseUrl);
                    //     } else {
                    //         // need a workaround for iOS 8
                    //         // - can run an http server
                    //         // - can copy files to /tmp
                    //         // - curious about symlink from /tmp -> Documents, but doubtful it will work
                    //     }
                    // } else {
                    //     NSUrlRequest request = new NSUrlRequest (url);
                    //     WebView.LoadRequest (request);
                    // }

                    NSUrlRequest request = new NSUrlRequest (url);
                    WebView.LoadRequest (request);
                } else {
                    var html = Composer.Bundle.FullHtml;
                    var url = new NSUrl (Composer.Bundle.BaseUrl.AbsoluteUri);
                    WebView.LoadHtmlString (new NSString(html), url);
                }
            }
        }

        #endregion

        #region Web View Delegate

        // These are WKWebView delegate methods
        // [Export ("webView:didFinishNavigation:")]
        // public void DidFinishNavigation (WebKit.WKWebView webView, WebKit.WKNavigation navigation)
        // {
        //     // The navigation is done, meaning the HTML has loaded in the web view, so we now have to
        //     // tell our scroll view how big the webview is.
        //     // Unfortunately, WebView.ScrollView.ContentSize.Height is still 0 at this point.
        //     // It's a timing issue, and so we'll wait until it's not 0
        //     UpdateScrollViewSizeOnceWebViewIsSized ();
        //     EnableEditingInWebView ();
        // }

        // [Export ("updateScrollViewSizeOnceWebViewIsSized")]
        // private void UpdateScrollViewSizeOnceWebViewIsSized ()
        // {
        //     // The basic idea is to keep scheduling ourselves in the run loop until we see a non-zero height.
        //     // Using the run loop is crucuial because it means we won't block anything.
        //     // Experiements show this usually takes anywhere from 1-4 itereations.
        //     if (WebView.ScrollView.ContentSize.Height == 0.0) {
        //         var selector = new ObjCRuntime.Selector ("updateScrollViewSizeOnceWebViewIsSized");
        //         var timer = NSTimer.CreateTimer (0.0, this, selector, null, false);
        //         NSRunLoop.Main.AddTimer (timer, NSRunLoopMode.Default);
        //     } else {
        //         UpdateScrollViewSize ();
        //     }
        // }

        // [Export ("userContentController:didReceiveScriptMessage:")]
        // public void DidReceiveScriptMessage (WKUserContentController userContentController, WKScriptMessage message)
        // {
        //     NSDictionary body = message.Body as NSDictionary;
        //     string kind = body.ObjectForKey (new NSString("kind")).ToString ();
        //     if (message.Name == "nacho") {
        //         if (kind == "error") {
        //             string errorMessage = body.ObjectForKey (new NSString("message")).ToString ();
        //             string filename = body.ObjectForKey (new NSString("filename")).ToString ();
        //             string lineno = body.ObjectForKey (new NSString("lineno")).ToString ();
        //             string colno = body.ObjectForKey (new NSString("colno")).ToString ();
        //             Log.Error(Log.LOG_UI, "MessageComposeView javascript uncaught error: [{1}:{2}:{3}] {0}", errorMessage, filename, lineno, colno);
        //         }
        //     } else if (message.Name == "nachoCompose") {
        //         if (kind == "editor-height-changed") {
        //             UpdateScrollViewSize ();
        //         }
        //     }
        // }

        [Export ("webViewDidFinishLoad:")]
        public void LoadingFinished (UIWebView webView)
        {
            IsWebViewLoaded = true;
            UpdateScrollViewSize ();
            EnableEditingInWebView ();
            foreach (var script in JavaScriptQueue) {
                EvaluateJavaScript (script);
            }
            JavaScriptQueue = null;
            if (MakeWebViewFirstResponderOnLoad) {
                MakeWebViewFirstResponder ();
            }
        }

        // An approximation of what WKWebView does with WKScriptMessageHandler
        public void HandleWebViewMessage (NcWebViewMessage message)
        {
            NSDictionary body = message.Body as NSDictionary;
            string kind = body.ObjectForKey (new NSString("kind")).ToString ();
            if (message.Name == "nachoCompose") {
                if (kind == "editor-height-changed") {
                    UpdateScrollViewSize ();
                }
            }
        }

        private void EnableEditingInWebView ()
        {
            EvaluateJavaScript ("Editor.Enable()");
        }

        private void MakeWebViewFirstResponder ()
        {
            EvaluateJavaScript ("Editor.defaultEditor.focus()");
        }

        private void EvaluateJavaScript(string javascript, WKJavascriptEvaluationResult callback = null)
        {
            if (IsWebViewLoaded) {
                // Here's how WKWebView would work
                // WebView.EvaluateJavaScript (new NSString(javascript), (NSObject result, NSError error) => {
                //     if (error !=  null){
                //         Log.Error(Log.LOG_UI, "MessageComposeView error evaluating javascript '{0}': {1}", javascript, error);
                //     }
                //     if (callback != null) {
                //         callback (result, error);
                //     }
                // });
                WebView.EvaluateJavascript (javascript);
            } else {
                JavaScriptQueue.Add (javascript);
            }
        }

        string JavaScriptEscapedString (string s)
        {
            var primitive = new System.Json.JsonPrimitive (s);
            string escaped = "";
            using (var writer = new StringWriter ()) {
                primitive.Save (writer);
                escaped = writer.ToString ();
            }
            return escaped.Replace("\n", "\\n");
        }

        [Foundation.Export("scrollViewWillBeginDragging:")]
        public void DraggingStarted (UIScrollView scrollView)
        {
        }

        [Foundation.Export("scrollViewDidScroll:")]
        public void Scrolled (UIScrollView scrollView)
        {
        }

        #endregion

        #region Helpers

        private void UpdateSendEnabled ()
        {
            SendButton.Enabled = Composer.HasRecipient;
        }

        private void ShowQuickResponses (bool animated = true)
        {
            NcQuickResponse.QRTypeEnum responseType = NcQuickResponse.QRTypeEnum.Compose;

            if (EmailHelper.IsReplyAction (Composer.Kind)) {
                responseType = NcQuickResponse.QRTypeEnum.Reply;
            } else if (EmailHelper.IsForwardAction (Composer.Kind)) {
                responseType = NcQuickResponse.QRTypeEnum.Forward;
            }

            var quickViewController = new QuickResponseViewController ();
            quickViewController.ResponseDelegate = this;
            quickViewController.SetProperties (responseType);
            PresentViewController (quickViewController, animated, null);
        }

        private string GetHtmlContent ()
        {
            // This is a sync call with UIWebView, but will be async with WKWebView,
            // which could cause havoc with the design of upstream callers
            return "<!DOCTYPE html>\n" + WebView.EvaluateJavascript ("document.documentElement.outerHTML");
        }

        #endregion

        #region Header View

        private void UpdateHeaderView ()
        {
            UpdateHeaderSubjectView ();
            UpdateHeaderToView ();
            UpdateHeaderCcView ();
            UpdateHeaderBccView ();
            UpdateHeaderIntentView ();
            UpdateHeaderAttachmentsView ();
        }

        private void UpdateHeaderToView ()
        {
            HeaderView.ToView.Clear ();
            var addresses = EmailHelper.AddressList (NcEmailAddress.Kind.To, null, Composer.Message.To);
            foreach (var address in addresses) {
                HeaderView.ToView.Append (address);
            }
        }

        private void UpdateHeaderCcView ()
        {
            HeaderView.CcView.Clear ();
            var addresses = EmailHelper.AddressList (NcEmailAddress.Kind.Cc, null, Composer.Message.Cc);
            foreach (var address in addresses) {
                HeaderView.CcView.Append (address);
            }
        }

        private void UpdateHeaderBccView ()
        {
            HeaderView.BccView.Clear ();
            var addresses = EmailHelper.AddressList (NcEmailAddress.Kind.Bcc, null, Composer.Message.Bcc);
            foreach (var address in addresses) {
                HeaderView.BccView.Append (address);
            }
        }

        private void UpdateHeaderSubjectView ()
        {
            HeaderView.SubjectField.Text = Composer.Message.Subject;
        }

        private void UpdateHeaderIntentView ()
        {
            HeaderView.IntentView.ValueLabel.Text = NcMessageIntent.GetIntentString (Composer.Message.Intent, Composer.Message.IntentDateType, Composer.Message.IntentDate);
        }

        private void UpdateHeaderAttachmentsView ()
        {
            HeaderView.AttachmentsView.Clear ();
            var attachments = McAttachment.QueryByItemId (Composer.Message);
            foreach (var attachment in attachments) {
                HeaderView.AttachmentsView.Append (attachment);
            }
        }

        #endregion

        #region Notifications

        private void RegisterForNotifications ()
        {
            BackgroundNotification = NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidEnterBackgroundNotification, OnBackgroundNotification);
            ContentSizeCategoryChangedNotification = NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ContentSizeCategoryChangedNotification, OnContentSizeCategoryChangedNotification);
        }

        private void UnregisterNotifications ()
        {
            NSNotificationCenter.DefaultCenter.RemoveObserver (BackgroundNotification);
            NSNotificationCenter.DefaultCenter.RemoveObserver (ContentSizeCategoryChangedNotification);
        }

        private void OnBackgroundNotification (NSNotification notification)
        {
            if (null != CloseAlertController) {
                CloseAlertController.DismissViewController (false, null);
            }
        }

        void OnContentSizeCategoryChangedNotification (NSNotification notification)
        {
            // TODO: can we do anything to update the webview font size?
        }

        #endregion

        public override bool ShouldEndEditing {
            get {
                return false;
            }
        }

    }

    #region Approximate WKScriptMessage for UIWebView

    // WKWebView has a way for Javascript running in a web page to call back to objective-c/c# code.
    // Communication from JS makes certain things easier, like knowing when the text in the web view has changed.
    // What follows is an approximation of what WKWebView does, making use of a custom protocol on this end and 
    // an XMLHttpRequest to a URL of that protocol on the JS end.
    // The custom protocol deciphers the message from the URL query string and dispatches the info to a delegate
    // similar to WKScriptMessageHandler

    public class NcWebViewMessage
    {
        public readonly string Name;
        public readonly NSObject Body;

        public NcWebViewMessage (string name, NSObject body)
        {
            Name = name;
            Body = body;
        }
    }

    public interface NcWebViewMessageHandler {
        void HandleWebViewMessage (NcWebViewMessage message);
    }

    public class NcWebViewMessageProtocol : NSUrlProtocol 
    {

        static bool Registered = false;
        static Dictionary<string, List<NcWebViewMessageHandler>> Handlers;

        public static void Register ()
        {
            if (!Registered) {
                NSUrlProtocol.RegisterClass (new ObjCRuntime.Class (typeof(NcWebViewMessageProtocol)));
                Registered = true;
            }
        }

        public static void AddHandler (NcWebViewMessageHandler handler, string name)
        {
            if (Handlers == null) {
                Handlers = new Dictionary<string, List<NcWebViewMessageHandler>> ();
            }
            if (!Handlers.ContainsKey (name)) {
                Handlers [name] = new List<NcWebViewMessageHandler> ();
            }
            Handlers [name].Add (handler);
        }

        [Export ("canInitWithRequest:")]
        public static bool canInitWithRequest (NSUrlRequest request)
        {
            if ((null == request) || (null == request.Url)) {
                return false;
            }
            return request.Url.Scheme == "nachomessage";
        }

        [Export ("canonicalRequestForRequest:")]
        public static new NSUrlRequest GetCanonicalRequest (NSUrlRequest forRequest)
        {
            return forRequest;
        }

        [Export ("initWithRequest:cachedResponse:client:")]
        public NcWebViewMessageProtocol (NSUrlRequest request, NSCachedUrlResponse cachedResponse, INSUrlProtocolClient client) : base (request, cachedResponse, client)
        {
        }

        public override void StartLoading ()
        {
            if ((null == Request) || (null == Request.Url)) {
                return;
            }
            var name = Request.Url.Host;
            var body = new NSMutableDictionary ();
            var components = new NSUrlComponents (Request.Url, false);
            foreach (var item in components.QueryItems) {
                var key = new NSString (item.Name);
                var value = new NSString (item.Value);
                body.SetObject (value, key);
            }
            var message = new NcWebViewMessage (name, body);
            using (var response = new NSUrlResponse (Request.Url, "text/plain", 0, "utf8")) {
                Client.ReceivedResponse (this, response, NSUrlCacheStoragePolicy.NotAllowed);
            }
            Client.FinishedLoading (this);
            Dispatch (message);
        }

        public override void StopLoading ()
        {
        }

        void Dispatch (NcWebViewMessage message)
        {
            if (Handlers.ContainsKey (message.Name)) {
                foreach (var handler in Handlers[message.Name]) {
                    InvokeOnUIThread.Instance.Invoke (() => {
                        handler.HandleWebViewMessage (message);
                    });
                }
            }
        }

    }

    #endregion

    public static class MessageComposeViewControllerWebViewHijacker {

        [DllImport ("/usr/lib/libobjc.dylib")]
        extern static IntPtr objc_allocateClassPair (IntPtr superclass, string name, IntPtr extraBytes);

        [DllImport ("/usr/lib/libobjc.dylib")]
        extern static void objc_registerClassPair (IntPtr cls);

        [DllImport ("/usr/lib/libobjc.dylib")]
        internal extern static bool class_addMethod (IntPtr cls, IntPtr name, IntPtr imp, IntPtr types);

        [DllImport ("/usr/lib/libobjc.dylib")]
        internal extern static IntPtr class_getInstanceMethod (IntPtr cls, IntPtr sel);

        [DllImport ("/usr/lib/libobjc.dylib")]
        internal extern static IntPtr class_getMethodImplementation (IntPtr cls, IntPtr sel);

        [DllImport ("/usr/lib/libobjc.dylib")]
        internal extern static IntPtr object_setClass (IntPtr obj, IntPtr cls);

        [DllImport ("/usr/lib/libobjc.dylib")]
        internal extern static IntPtr method_getTypeEncoding (IntPtr method);

        [DllImport ("/usr/lib/libobjc.dylib")]
        internal extern static IntPtr method_getImplementation (IntPtr method);

        private static string BrowserViewClassWithoutAccessoryViewName = "UIWebBrowserViewNcHijacked";
        private static ObjCRuntime.Class HijackedBrowserViewClass = null;

        public static void NcHijack (this UIWebView webView)
        {
            // Several UIWebView behaviors (input accessory bar above keyboard, menu controller actions)
            // are actually executed by a private subview of UIWebView, the UIWebBrowserView.  Since it's
            // a private class, we can't subclass it directly and override methods.  Instead, we'll create a
            // new subclass dynamically at runtime and switch the private browser view instance of this web view
            // into an instance of our new subclass
            var browserView = webView.NcBrowserView ();
            if (browserView != null) {
                if (HijackedBrowserViewClass == null) {
                    CreateHijackedBrowserViewClass (browserView.Class);
                }
                if (!browserView.IsKindOfClass (HijackedBrowserViewClass)) {
                    object_setClass (browserView.Handle, HijackedBrowserViewClass.Handle);
                }
            }
        }

        public static UIView NcBrowserView (this UIWebView webView)
        {
            // This depends entirely on private Apple conventions of naming and view tree construction.
            // So if Apple changes things, this will break.  But it works for now...
            // We're looking for something called UIWebBrowserView, but we'll do a StartsWith search because
            // we still want to find the browser view even after we've switched to our subclass, which is named
            // UIWebBrowserViewNcHijacked.
            foreach (var subview in webView.ScrollView.Subviews) {
                if (subview.Class.Name.StartsWith ("UIWebBrowserView")) {
                    return subview;
                }
            }
            return null;
        }

        public static void CreateHijackedBrowserViewClass (ObjCRuntime.Class browserViewClass)
        {
            // We have to create a new subclass at runtime because UIWebBrowserView is private.  Runtime requires us to use
            // the low level objc_* methods, which we've loaded into c# land using the import statements above.
            // The basic steps are:
            // 1. Allocate a new subclass of browserViewClass
            // 2. Add new methods to the subclass that override UIWebBrowserView methods
            // 3. Register the new class
            IntPtr hijackedClassHandle = objc_allocateClassPair (browserViewClass.Handle, BrowserViewClassWithoutAccessoryViewName, IntPtr.Zero);

            HijackBrowserViewAccessoryInputView (browserViewClass, hijackedClassHandle);
            HijackBrowserViewCanPerformAction (browserViewClass, hijackedClassHandle);
            HijackBrowserViewPaste (browserViewClass, hijackedClassHandle);

            objc_registerClassPair(hijackedClassHandle);
            HijackedBrowserViewClass = new ObjCRuntime.Class (hijackedClassHandle);
        }

        #region InputAccessoryView

        public static void HijackBrowserViewAccessoryInputView (ObjCRuntime.Class browserViewClass, IntPtr hijackedClassHandle)
        {
            // We want to hijack the inputAccessoryView method because the default implementation adds a bar above the keyboar
            // with <, >, and Done buttons.  The bar is pointless in our use case and it just takes up space.  So our replacement
            // method will return null, removing the bar.  We could design our own bar and return that if we wanted.
            var selector = new ObjCRuntime.Selector ("inputAccessoryView");
            var baseMethod = class_getInstanceMethod (browserViewClass.Handle, selector.Handle);
            var types = method_getTypeEncoding (baseMethod);
            InputAccessoryViewDelegate d = BrowserView_InputAccessoryView;
            var imp = Marshal.GetFunctionPointerForDelegate(d);
            class_addMethod (hijackedClassHandle, selector.Handle, imp, types);
        }

        // Our C# Delegate signatures are derived from the low-level Objective-C IMP signatures.
        // IMPs are function pointers that are derived from the high-level Objetive-C method definitions.
        //
        // IMPs take at least two arguments: self (an id) and selector (a SEL).
        // Any further arguments are the actual method arguments.
        //
        // To get from C to C#, pointer types turn into IntPtr and primitives remian the same.  Objective-C
        // has a lot of typedefs that obscure the reality that most of them are just pointers
        // (e.g. id is "typedef struct objc_object *id", or SEL is "typedef struct objc_selector *SEL")
        //
        // Starting from an Objective-C signature, we can get the appropriate C# signature:
        //    Objective-C signature: - (UIView *)inputAccessoryView
        // -> IMP signature: id(*)(id self, SEL selector)
        // -> C# signature IntPtr (IntPtr self, IntPtr selector)
        //
        // Underneath the hood, Objective-C methods are function pointers that always have self and the selector as the
        // first two arguments.  Any further arguments are the actual method arguments.
        // To convert from and IMP signature to a C# signature, pointers become IntPtr and primitives 
        [ObjCRuntime.MonoNativeFunctionWrapper]
        delegate IntPtr InputAccessoryViewDelegate (IntPtr self, IntPtr selector);

        [ObjCRuntime.MonoPInvokeCallback (typeof (InputAccessoryViewDelegate))]
        static IntPtr BrowserView_InputAccessoryView (IntPtr self, IntPtr selector)
        {
            return new IntPtr(0);
        }

        #endregion

        #region CanPerformAction

        public static void HijackBrowserViewCanPerformAction (ObjCRuntime.Class browserViewClass, IntPtr hijackedClassHandle)
        {
            // We want to hijack the canPerformAction:withSender: method so we can add our own menu controller options (like Attach),
            // or remove predefined ones in cases where they can't work (like Paste, sometimes).  Since we'll generally fallback to the
            // original implementation, we'll keep a reference to call in situations where base() would be used for a typical subclass.
            var selector = new ObjCRuntime.Selector ("canPerformAction:withSender:");
            var baseMethod = class_getInstanceMethod (browserViewClass.Handle, selector.Handle);
            var types = method_getTypeEncoding (baseMethod);
            BrowserView_OriginalCanPerformAction = method_getImplementation (baseMethod);
            CanPerformActionDelegate d = BrowserView_CanPerformAction;
            var imp = Marshal.GetFunctionPointerForDelegate(d);
            class_addMethod (hijackedClassHandle, selector.Handle, imp, types);
        }

        static IntPtr BrowserView_OriginalCanPerformAction;

        [ObjCRuntime.MonoNativeFunctionWrapper]
        delegate bool CanPerformActionDelegate (IntPtr self, IntPtr selector, IntPtr action, IntPtr sender);

        [ObjCRuntime.MonoPInvokeCallback (typeof (CanPerformActionDelegate))]
        static bool BrowserView_CanPerformAction (IntPtr selfHandle, IntPtr selectorHandle, IntPtr actionHandle, IntPtr senderHandle)
        {
            var action = new ObjCRuntime.Selector (actionHandle);
            Log.Info (Log.LOG_UI, "NcWebBrowserViewProxy CanPerform: {0}", action.Name);
            var d = (CanPerformActionDelegate)Marshal.GetDelegateForFunctionPointer (BrowserView_OriginalCanPerformAction, typeof(CanPerformActionDelegate));
            bool canPerform = d (selfHandle, selectorHandle, actionHandle, senderHandle);
            return canPerform;
        }

        #endregion

        #region Paste

        public static void HijackBrowserViewPaste (ObjCRuntime.Class browserViewClass, IntPtr hijackedClassHandle)
        {
            // We want to hijack the paste: method so we can handle pasting of images.  The default implementation adds an image
            // to the web view with a private webkit-fake-url:// scheme, and we can't get the data.  But if we intercept the paste
            // before it even gets there, we can capture the image and insert our own HTML.
            var selector = new ObjCRuntime.Selector ("paste:");
            var baseMethod = class_getInstanceMethod (browserViewClass.Handle, selector.Handle);
            var types = method_getTypeEncoding (baseMethod);
            BrowserView_OriginalPaste = method_getImplementation (baseMethod);
            PasteDelegate d = BrowserView_Paste;
            var imp = Marshal.GetFunctionPointerForDelegate(d);
            class_addMethod (hijackedClassHandle, selector.Handle, imp, types);
        }

        static IntPtr BrowserView_OriginalPaste;

        [ObjCRuntime.MonoNativeFunctionWrapper]
        delegate void PasteDelegate (IntPtr self, IntPtr selector, IntPtr sender);

        [ObjCRuntime.MonoPInvokeCallback (typeof (PasteDelegate))]
        static void BrowserView_Paste (IntPtr self, IntPtr selector, IntPtr sender)
        {
            var d = (PasteDelegate)Marshal.GetDelegateForFunctionPointer (BrowserView_OriginalPaste, typeof(PasteDelegate));
            d (self, selector, sender);
        }

        #endregion

    }

}
