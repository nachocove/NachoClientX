// This file has been autogenerated from a class added in the UI designer.

using System;
using System.Collections.Generic;
using MonoTouch.Foundation;
using MonoTouch.UIKit;
using NachoCore.Model;
using NachoCore.Utils;
using NachoCore.Brain;

namespace NachoClient.iOS
{
    public partial class MessagePriorityViewController : BlurryViewController, INachoMessageEditor
    {
        public McEmailMessageThread thread;
        protected INachoMessageEditorParent owner;

        enum DatePickerActionType
        {
            None,
            Defer,
            Deadline,
        };

        DatePickerActionType datePickerAction = DatePickerActionType.None;

        public MessagePriorityViewController (IntPtr handle) : base (handle)
        {
        }

        public void SetOwner (INachoMessageEditorParent o)
        {
            owner = o;
        }

        public void DismissMessageEditor (bool animated, NSAction action)
        {
            owner = null;
            DismissViewController (animated, action);
        }

        public override void ViewDidLoad ()
        {
            base.ViewDidLoad ();

            DateTime earliestDelay = DateTime.MaxValue;
            foreach (var message in thread) {
                if (earliestDelay > message.FlagUtcDeferUntil) {
                    earliestDelay = message.FlagUtcDeferUntil;
                }
            }

            if (DateTime.UtcNow > earliestDelay) {
                ;
            } else if (1 == thread.Count) {
                currentDelayLabel.Text = String.Format ("Deferred until {0}.", earliestDelay);
            } else {
                currentDelayLabel.Text = String.Format ("Visible after {0}.", earliestDelay);
            }

            meetingButton.TouchUpInside += (object sender, EventArgs e) => {
                CreateMeeting ();
            };
            taskButton.TouchUpInside += (object sender, EventArgs e) => {
                CreateTask ();
            };
            deadlineButton.TouchUpInside += (object sender, EventArgs e) => {
                CreateDeadline ();
            };
            laterButton.TouchUpInside += (object sender, EventArgs e) => {
                DelayRequest (MessageDeferralType.Later);
            };
            tonightButton.TouchUpInside += (object sender, EventArgs e) => {
                DelayRequest (MessageDeferralType.Tonight);
            };
            tomorrowButton.TouchUpInside += (object sender, EventArgs e) => {
                DelayRequest (MessageDeferralType.Tomorrow);
            };
            nextWeekButton.TouchUpInside += (object sender, EventArgs e) => {
                DelayRequest (MessageDeferralType.NextWeek);
            };
            nextMonthButton.TouchUpInside += (object sender, EventArgs e) => {
                DelayRequest (MessageDeferralType.NextMonth);
            };
            deferDatePicker.TouchUpInside += (object sender, EventArgs e) => {
                DelayRequest (MessageDeferralType.Custom);
            };
            dismissButton.TouchUpInside += (object sender, EventArgs e) => {
                DismissViewController (true, null);
            };

        }

        /// Touch anywhere else, and we'll close this view
        public override void TouchesBegan (NSSet touches, UIEvent evt)
        {
            owner.DismissChildMessageEditor (this);
        }

        public override void PrepareForSegue (UIStoryboardSegue segue, NSObject sender)
        {
            var blurry = segue.DestinationViewController as BlurryViewController;
            if (null != blurry) {
                blurry.CaptureView (this.View);
            }

            if (segue.Identifier == "MessagePriorityToDatePicker") {
                var vc = (DatePickerViewController)segue.DestinationViewController;
                vc.owner = this;
            }
        }
        // TODO: Do we need to worry about local vs. utc time?
        public void DismissDatePicker (DatePickerViewController vc, DateTime chosenDateTime)
        {
            if (DateTime.UtcNow > chosenDateTime) {
                // TODO -- Confirm that the user wants to go back in time.
                return;
            } 
            switch (datePickerAction) {
            case DatePickerActionType.Defer:
                NcMessageDeferral.DeferThread (thread, MessageDeferralType.Custom, chosenDateTime);
                break;
            case DatePickerActionType.Deadline:
                NcMessageDeferral.SetDueDate (thread, chosenDateTime);
                break;
            }
            vc.owner = null;
            vc.DismissViewController (false, new NSAction (delegate {
                owner.DismissChildMessageEditor (this);
            }));
        }

        void DelayRequest (MessageDeferralType request)
        {
            DateTime now = DateTime.Now;

            switch (request) {
            case MessageDeferralType.Later:
            case MessageDeferralType.Tonight:
            case MessageDeferralType.Tomorrow:
            case MessageDeferralType.NextWeek:
            case MessageDeferralType.MonthEnd:
            case MessageDeferralType.NextMonth:
            case MessageDeferralType.Forever:
                NcMessageDeferral.DeferThread (thread, request);
                owner.DismissChildMessageEditor (this);
                return;
            case MessageDeferralType.Custom:
                datePickerAction = DatePickerActionType.Defer;
                PerformSegue ("MessagePriorityToDatePicker", this);
                break;
            case MessageDeferralType.None:
            default:
                NcAssert.CaseError ();
                return;
            }
        }

        void CreateMeeting ()
        {
            owner.CreateMeetingEmailForMessage (this, thread);
        }

        void CreateTask ()
        {
            owner.CreateTaskForEmailMessage (this, thread);
        }

        void CreateDeadline ()
        {
            datePickerAction = DatePickerActionType.Deadline;
            PerformSegue ("MessagePriorityToDatePicker", this);
        }
    }
}
