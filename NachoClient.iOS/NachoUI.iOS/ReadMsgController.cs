// This file has been autogenerated from a class added in the UI designer.


using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Text;

using MonoTouch.Foundation;
using MonoTouch.UIKit;
using NachoCore;
using NachoCore.Model;
using MimeKit;
using MimeKit.Utils;
using MimeKit.IO;


namespace NachoClient.iOS
{
	public partial class ReadMsgController : UIViewController
	{

		/*  Code from unit tests, - example on use of MimeKit
		 * using (var source = new MemoryStream (Encoding.UTF8.GetBytes (rawMessageText))) {
				var parser = new MimeParser (source, MimeFormat.Default);
				var message = parser.ParseMessage ();
				*/

		AppDelegate appDelegate { get; set; }
		NcEmailMessage currentMessage { get; set; }

		public void SetMessage (NcEmailMessage ncemailmsg) {
			currentMessage = ncemailmsg;
		}

		public override void PrepareForSegue (UIStoryboardSegue segue, NSObject sender)
		{
			base.PrepareForSegue (segue, sender);
			NcEmailMessage thisemailmsg;

			if (segue.Identifier == "replymessagesegue" ){
				var replymsg = (ReplyViewController)segue.DestinationViewController; //our destination



				replymsg.SetMessage(currentMessage);
			};
		}

		private void createMessage(){
			//try to create a MIME formatted message using msg data
			var mymsg = new MimeMessage (	new Header ("From", "chrisp@nachocove.com"),
			                           new Header ("To", "jeffe@xnachocove.com"),
			                           new Header[] { new Header ("Cc", "chris.perret@nachocove.com"), new Header ("Cc", "chris.perret13@gmail.com") },
									   new Header ("Subject", "Hello"),
									   new TextPart ("plain", "Just a short message to say hello!")
			);
		

			//Console.WriteLine (mymsg.Body.ToString);
			// var buffer = new MemoryStream ();
			//mymsg.WriteTo (buffer);

			//Console.WriteLine ((string)buffer.ToArray);

			//mymsg..DecodeTo (buffer);
			//buffer.Seek (0, SeekOrigin.Begin);

			Console.Write ("NYI");

		}


		//  Start of full rendering engine. Will ultimately be in a Core package (I THink)
		 bool CanRenderPart (MimePart part){
			if (part.ContentDisposition != null && part.ContentDisposition.Disposition.ToLower () != "inline")
			return false;

			// we should probably render all text parts that aren't explicitly marked as attachments
			if (part.ContentType.Matches ("text", "*"))
			return true;

			// we have libraries for rendering jpegs, so let's render those...
			if (part.ContentType.Matches ("image", "jpeg"))
			return true;

			// we don't know how to handle these other mime-types...
			return false;
		}


void RenderEntity (MimeEntity entity, UIWebView webview)
			// IList<MimePart> attachments)
		{
			if (entity is MessagePart) {
				var msgpart = (MessagePart)entity;

				// if you're going to render attached messages inline, you'll probably want to render the headers
				// and then render the message contents:
				RenderEntity (msgpart.Message.Body, webview); // attachments);
			} else if (entity is Multipart) {
				var multipart = (Multipart)entity;

				foreach (var subpart in multipart)
					RenderEntity (subpart, webview); //attachments);
			} else {
				var part = (MimePart)entity; // now we are in a leaf node

				if (CanRenderPart (part)) {
					// render the part content somehow... for textual parts, we can just get the TextPart.Text value and slap that in the webview
					// for images, we'll have to do something else... like possibly generating some simple html to reference a temp file to load the image or something?
					// or perhaps there is a way to stream the image to the webview with a way to name it, so that the html can reference it?
					DisplayPart (part, webview);
				} else {
					// this part was either explicitly marked as an attachment or we can't render the file format, so add it to our list of attachments
					FindAttachment (part, webview);
					// do we need to add a list of attachments to be rendered at right time? I think so ...
					//attachments.Add (part);
				}
			}
		}

		void FindAttachment(MimePart part, UIWebView webview){
			// if we have an attachment, get it and then determine how to display. 
			// depending on size and other information, we may decide to throw pop up button to download,
			// display a thumbnail, or display in-line (even though its an attachment)
			//  ContentDisposition set to !in-line tells us that it is supposed to be an attachmnet.


			NSData data;


			var MyPath = appDelegate.Be.AttachmentsDir;
			var filename = part.FileName;
			var contentDirectoryPath = Path.Combine (MyPath, filename);
			var memory = new MemoryBlockStream ();
			byte[] binaryData;

			Console.WriteLine("Debug - FindAttachment");
			// eventually make this a tmp process, but for now do it here ...

			if (part.ContentObject != null) {
				part.ContentObject.DecodeTo (memory);
				data = NSData.FromArray (memory.ToArray ());
			} else {
				// somehow we got here, return without taking action
				return;
			}


			// part needs to be of type "not-inine", then we need to find the file name, the data and determine if we have downloaded it
			if (part.ContentDisposition != null && part.ContentDisposition.Disposition.ToLower () != "inline") {
				// its an attachment
				// FIXME - need to add an alert button to allow for user to download and display content
				//     right now we dont know how to display
				// we will open file in default location-> write file data to location, then open/display
				//var fd = File.Create (contentDirectoryPath);
				//if (fd.CanWrite) {
				//	Console.Write ("can Write - True");
				//}


				//File.OpenWrite (contentDirectoryPath);
				binaryData = memory.ToArray ();
				File.WriteAllBytes (contentDirectoryPath, binaryData);
				//fd.Close ();

			

			


				//File.WriteAllBytes (contentDirectoryPath, part.ContentObject.Stream);

				var buttonRect = UIButton.FromType(UIButtonType.RoundedRect);
				// example code to resize on an alertview, wonder if will work on webview.
				/*
				 *  else if (view is UIButton)
        			{
            			view.Frame = new RectangleF(
               			 ((alertView.Frame.Width) / 2) * (view.Tag - 1) + 20,
                			view.Frame.Y,
               			 (alertView.Frame.Width) / 2 - 40,
                		view.Frame.Height
                		);
       				 }

   				 */


				buttonRect.SetTitle ("Button!", UIControlState.Normal);
				// FIXME - buttonRect.Frame.Height = (webview.Frame.Height /2) *(buttonRect.Tag -1) + 20

				Console.WriteLine(part.ContentDisposition.Disposition.ToLower());
				// add code to download the data to a file based on button push
				//this.View.Draw (buttonRect);
			}
		
			var showme = new UIImage (data);


			var showmeview = new UIImageView (showme);
		


			webview.AddSubview (showmeview);
			//var attach = part.ContentObject.Stream;// dont need to copy multiple times ...
			//var mystr = attach.ToString ();
			//var dd = new NSData (mystr, null);
			//var datafile = new MemoryStream ();
			//part.ContentObject.DecodeTo (datafile);
		

			//webview.LoadData ((NSData) datafile.GetBuffer () [0], "image/tiff", "base64", new NSUrl (contentDirectoryPath, false));

			// Will cast contentObject.Stream to byearray/NSData

			//webview.LoadData (datafile.GetBuffer(), "tiff", "base-64", new NSUrl (contentDirectoryPath, false));
		

		}



		void DisplayPart ( MimePart part, UIWebView webview) {
			string contentDirectoryPath = appDelegate.Be.AttachmentsDir;

			if (part.ContentType.Matches ("html", "*")) {
				Console.WriteLine (" Displaying a  HTML Part");
				webview.LoadHtmlString (((TextPart)part).Text, new NSUrl (contentDirectoryPath, false));
			} else if (part.ContentType.Matches ("text", "*")) {
				Console.WriteLine ("Displaying a TextPart ");
				webview.LoadHtmlString (((TextPart)part).Text, new NSUrl (contentDirectoryPath, false));
			} else if (part.ContentType.Matches ("image", "*")) {
				Console.WriteLine ("Displaying an Image");
				/* write some code to point webview to the directory path */
				// something something something
			} else if (part.ContentType.Matches ("application", "*")) {
				Console.WriteLine ("Display an Application");
			};
		}

/*
		public void DumpMessage( MimeEntity Msg) {
			var builder = new StringBuilder ();

			var source = new MemoryStream (Encoding.UTF8.GetBytes (curMsg.Body));


			var parser = new MimeParser (source, MimeFormat.Default);
		
			//while (!parser.IsEndOfStream) {
			var message = parser.ParseMessage ();

			//builder.AppendFormat ("{0}\n", parser.MboxMarker);
			if (message.From.Count > 0)
				builder.AppendFormat ("From: {0}\n", message.From);
			if (message.To.Count > 0)
				builder.AppendFormat ("To: {0}\n", message.To);
			builder.AppendFormat ("Subject: {0}\n", message.Subject);
			builder.AppendFormat ("Date: {0}\n", DateUtils.FormatDate (message.Date));
			DumpMimeTree (builder, message.Body, 0);
			builder.Append ("\n");

		}
*/



		public override void ViewDidLoad ()
		{
			string contentDirectoryPath = "here/";
			base.ViewDidLoad ();
			// need to see senders NcEname
			var webView = new UIWebView (View.Bounds);
			View.AddSubview(webView);


			//DumpMessage (currentMessage);

			// below source code assumes that single message is what will be parsed and is what is contained
			// if we want to see multiple messages there would be additional "Format" options used
			// creation of parser. 
			//
			var source = new MemoryStream (Encoding.UTF8.GetBytes (currentMessage.Body));
		
			
			var parser = new MimeParser (source, MimeFormat.Default);
	
			var message = parser.ParseMessage ();

			
			//var attach = new IList<MimePart>;
			var attachments = new IList<MimePart>[0];

			RenderEntity (message.Body, webView); //attachments);




			Console.Write ("Display Email :");
			Console.WriteLine (currentMessage.From);
			Console.WriteLine (currentMessage.Body);

			//Console.Write (" +++++++++++");
		
			Console.WriteLine("< EOM >");


			//webView.LoadHtmlString(((TextPart) part).Text, new NSUrl(contentDirectoryPath, false));

		}
		partial void btnReplyMessage (MonoTouch.Foundation.NSObject sender){
			Console.WriteLine("Reply Button Pushed");
		}

		public ReadMsgController (IntPtr handle) : base (handle)
		{
		
			appDelegate = (AppDelegate)UIApplication.SharedApplication.Delegate;

		}
	}
}
