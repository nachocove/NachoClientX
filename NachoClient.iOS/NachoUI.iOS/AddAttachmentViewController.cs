// This file has been autogenerated from a class added in the UI designer.

using AssetsLibrary;
using System;
using System.Linq;
using System.Runtime.InteropServices;
using CoreGraphics;
using System.Collections.Generic;
using Foundation;
using UIKit;
using EventKit;
using System.IO;
using NachoCore;
using NachoCore.Model;
using NachoCore.Utils;

namespace NachoClient.iOS
{
    public partial class AddAttachmentViewController : NcUIViewControllerNoLeaks
    {

        const float BUTTON_SIZE = 64;
        const float BUTTON_LABEL_HEIGHT = 40;
        const float BUTTON_PADDING_HEIGHT = 15;
        const float BUTTON_PADDING_WIDTH = 35;

        protected McAccount account;
        protected McAbstrCalendarRoot c;
        protected INachoFileChooserParent owner;
        List<McAttachment> AttachmentsList = new List<McAttachment> ();
        List<ButtonInfo> buttonInfoList;
        UIBarButtonItem DismissButton;

        public AddAttachmentViewController (IntPtr handle) : base (handle)
        {
        }

        public void SetOwner (INachoFileChooserParent owner, McAccount account)
        {
            this.owner = owner;
            this.account = account;
        }

        public override void ViewDidLoad ()
        {
            base.ViewDidLoad ();
            CreateViewHierarchy ();
        }

        public override void ViewWillDisappear (bool animated)
        {
            base.ViewWillDisappear (animated);
        }

        public override void PrepareForSegue (UIStoryboardSegue segue, NSObject sender)
        {
            if (segue.Identifier.Equals ("AddAttachmentToAttachments")) {
                var dc = (FileListViewController)segue.DestinationViewController;
                dc.SetOwner (owner);
                dc.SetModal (true);
                return;
            }
            Log.Info (Log.LOG_UI, "Unhandled segue identifer {0}", segue.Identifier);
            NcAssert.CaseError ();
        }

        protected const int DISMISS_TAG = 1000;
        protected const int BUTTON_TAG = 2000;

        protected override void CreateViewHierarchy ()
        {
            UIView priorityView = new UIView (View.Frame);
            priorityView.ClipsToBounds = true;
            priorityView.BackgroundColor = A.Color_NachoGreen;

            var navBar = new UINavigationBar (new CGRect (0, 20, View.Frame.Width, 44));
            navBar.BarStyle = UIBarStyle.Default;
            navBar.Opaque = true;
            navBar.Translucent = false;

            var navItem = new UINavigationItem ("Add Attachment");
            using (var image = UIImage.FromBundle ("modal-close")) {
                DismissButton = new NcUIBarButtonItem (image, UIBarButtonItemStyle.Plain, null);
                DismissButton.AccessibilityLabel = "Close";
                DismissButton.Clicked += dismissClicked;
                navItem.LeftBarButtonItem = DismissButton;
            }
            navBar.Items = new UINavigationItem[] { navItem };

            priorityView.AddSubview (navBar);
            nfloat yOffset = 64;

            Util.AddHorizontalLine (0, yOffset, View.Frame.Width, UIColor.LightGray, priorityView);
            yOffset += 2;

            yOffset += 60;

            buttonInfoList = new List<ButtonInfo> (new ButtonInfo[] {
                new ButtonInfo ("Add Photo", "calendar-add-photo", () => SetupPhotoPicker (false)),
                new ButtonInfo ("Take Photo", "calendar-take-photo", () => SetupPhotoPicker (true)),
                new ButtonInfo ("Add File", "calendar-add-files", () => SetupAttachmentChooser ()),
                null,
            });

            var center = priorityView.Center;
            center.X = (priorityView.Frame.Width / 2);
            center.Y = center.Y;

            var xOffset = center.X - BUTTON_SIZE - BUTTON_PADDING_WIDTH;

            int i = 0;
            foreach (var buttonInfo in buttonInfoList) {
                if (null == buttonInfo) {
                    xOffset += BUTTON_SIZE + BUTTON_PADDING_WIDTH;
                    continue;
                }
                if (null == buttonInfo.buttonLabel) {
                    xOffset = center.X - BUTTON_SIZE - BUTTON_PADDING_WIDTH;
                    yOffset += BUTTON_SIZE + BUTTON_LABEL_HEIGHT + BUTTON_PADDING_HEIGHT;
                    continue;
                }

                var buttonRect = UIButton.FromType (UIButtonType.RoundedRect);
                buttonRect.Layer.CornerRadius = BUTTON_SIZE / 2;
                buttonRect.Layer.MasksToBounds = true;
                buttonRect.Layer.BorderColor = UIColor.LightGray.CGColor;
                buttonRect.Layer.BorderWidth = .5f;  
                buttonRect.Tag = BUTTON_TAG + i;
                buttonRect.Frame = new CGRect (0, 0, BUTTON_SIZE, BUTTON_SIZE);
                buttonRect.Center = new CGPoint (xOffset, yOffset);
                buttonRect.AccessibilityLabel = "Add attachment";
                using (var image = UIImage.FromBundle (buttonInfo.buttonIcon).ImageWithRenderingMode (UIImageRenderingMode.AlwaysOriginal)) {
                    buttonRect.SetImage (image, UIControlState.Normal);
                }
                buttonRect.TouchUpInside += (object sender, EventArgs e) => {
                    buttonInfo.buttonAction ();
                };
                priorityView.Add (buttonRect);

                var label = new UILabel ();
                label.TextColor = UIColor.White;
                label.Text = buttonInfo.buttonLabel;
                label.Font = A.Font_AvenirNextMedium14;
                label.TextAlignment = UITextAlignment.Center;
                label.SizeToFit ();
                label.Center = new CGPoint (xOffset, 5 + yOffset + ((BUTTON_SIZE + BUTTON_LABEL_HEIGHT) / 2));
                priorityView.Add (label);

                xOffset += BUTTON_SIZE + BUTTON_PADDING_WIDTH;
                i++;
            }

            View.AddSubview (priorityView);
        }

        public void dismissClicked (object sender, EventArgs e)
        {
            DismissViewController (true, null);
        }

        protected override void Cleanup ()
        {
            DismissButton.Clicked -= dismissClicked;
            DismissButton = null;

            //TODO
//            int i = 0;
//            foreach (var buttonInfo in buttonInfoList) {
//                UIButton button = (UIButton)View.ViewWithTag (BUTTON_TAG + i);
//                button = null;
//                i++;
//            }
        }

        public void SetupAttachmentChooser ()
        {
            PerformSegue ("AddAttachmentToAttachments", this);
        }

        protected override void ConfigureAndLayout ()
        {
        }

        //source is true if using camera
        //source is false if using photo library
        public void SetupPhotoPicker (bool source)
        {
            var imagePicker = new UIImagePickerController ();
            imagePicker.NavigationBar.Translucent = false;
            imagePicker.NavigationBar.BarTintColor = A.Color_NachoGreen;
            imagePicker.NavigationBar.TintColor = A.Color_NachoBlue;

            if (source) {
                if (UIImagePickerController.IsSourceTypeAvailable (UIImagePickerControllerSourceType.Camera)) {
                    imagePicker.SourceType = UIImagePickerControllerSourceType.Camera;
                } else {
                    Util.ComplainAbout ("Error", "Your device does not have a camera");
                }
            } else {
                imagePicker.SourceType = UIImagePickerControllerSourceType.PhotoLibrary;
            }

            imagePicker.FinishedPickingMedia += HandleFinishedPickingMedia;
            imagePicker.Canceled += HandleCanceled;

            imagePicker.ModalPresentationStyle = UIModalPresentationStyle.CurrentContext;
            this.PresentViewController (imagePicker, true, null);
            MaintainLightStyleStatusBar ();
        }

        protected void HandleCanceled (object sender, EventArgs e)
        {
            var imagePicker = sender as UIImagePickerController;
            imagePicker.DismissViewController (true, null);
            MaintainLightStyleStatusBar ();
        }

        protected void HandleFinishedPickingMedia (object sender, UIImagePickerMediaPickedEventArgs ea)
        {
            Action complete = () => {
                ea.Info.Dispose ();
                owner.DismissPhotoPicker ();
                MaintainLightStyleStatusBar ();
            };
            const string KCommonFailMessage = "Could not Attach Image/Movie";
            const string KCommonNoAccess = "We were not able to access the chosen image/movie.";
            var imageUrl = ea.Info [UIImagePickerController.ReferenceUrl];
            var mediaUrl = ea.Info [UIImagePickerController.MediaURL];
            var assetUrl = ((null == imageUrl) ? mediaUrl : imageUrl) as NSUrl;
            if (null != assetUrl) {
                using (var aLib = new ALAssetsLibrary ()) {
                    aLib.AssetForUrl (assetUrl, 
                        (asset) => {
                            if (null == asset) {
                                Log.Error (Log.LOG_UI, "AddAttachmentViewController:HandleFinishedPickingMedia: null asset for {0}", assetUrl.ToString ());
                                complete ();
                                NcAlertView.ShowMessage (PresentingViewController, KCommonFailMessage, KCommonNoAccess);
                                return;
                            }
                            var assetRepr = asset.DefaultRepresentation;
                            if (null == assetRepr) {
                                // TODO - attach on ALAssetsLibraryChangedNotification and send later.
                                Log.Error (Log.LOG_UI, "AddAttachmentViewController:HandleFinishedPickingMedia: need ALAssetsLibraryChangedNotification");
                                complete ();
                                NcAlertView.ShowMessage (PresentingViewController, KCommonFailMessage,
                                    "The chosen image/movie is from a shared photo stream that is not yet available locally.");
                                return;
                            }
                            var policy = McPolicy.QueryByAccountId<McPolicy> (account.Id).SingleOrDefault ();
                            if (null != policy && policy.MaxAttachmentSizeEnabled &&
                            assetRepr.Size > policy.MaxAttachmentSizeBytes) {
                                Log.Info (Log.LOG_UI, "AddAttachmentViewController:HandleFinishedPickingMedia: Too Big: {0} < {1}", policy.MaxAttachmentSizeBytes, assetRepr.Size);
                                complete ();
                                NcAlertView.ShowMessage (PresentingViewController, KCommonFailMessage,
                                    (policy.MaxAttachmentSizeBytes > 1024*1024) ?
                                    string.Format ("The server prohibits attachments larger than {0} MB.", policy.MaxAttachmentSizeBytes/1024*1024) :
                                    string.Format ("The server prohibits attachments larger than {0} bytes.", policy.MaxAttachmentSizeBytes));
                                return;
                            }
                            // Can't find a clean way to copy from the AL URL over to file system. 
                            // Seems to force us to handle the bytes directly.
                            var attachment = McAttachment.InsertFile (account.Id, (stream) => {
                                var remaining = (nuint)assetRepr.Size;
                                long offset = 0;
                                const int blockSize = 4096;
                                byte[] managedPad = new byte[blockSize];
                                var pad = Marshal.AllocHGlobal (blockSize);
                                using (var writer = new BinaryWriter (stream)) {
                                    while (0 < remaining) {
                                        NSError error = null;
                                        var chunkSize = (remaining > blockSize) ? blockSize : remaining;
                                        assetRepr.GetBytes (pad, offset, chunkSize, out error);
                                        // FIXME error.
                                        offset += (long)chunkSize;
                                        remaining -= chunkSize;
                                        Marshal.Copy(pad, managedPad, 0, blockSize);
                                        writer.Write (managedPad, 0, (int)chunkSize);
                                    }
                                }
                                Marshal.FreeHGlobal (pad);
                            });
                            var displayName = assetRepr.Filename;
                            if (null == displayName) {
                                Log.Error (Log.LOG_UI, "AddAttachmentViewController:HandleFinishedPickingMedia: assetRepr.Filename is null");
                                displayName = "attachment";
                                // TODO - if this ever really happens, we need to add correct suffix.
                            }
                            attachment.SetDisplayName (displayName);
                            attachment.UpdateSaveFinish ();
                            owner.Append (attachment);
                            complete ();
                        },
                        (error) => {
                            Log.Error (Log.LOG_UI, "AddAttachmentViewController:HandleFinishedPickingMedia: NsError2: {0}", error.ToString ());
                            complete ();
                            NcAlertView.ShowMessage (PresentingViewController, KCommonFailMessage, KCommonNoAccess);
                        });
                }
            } else {
                Log.Error (Log.LOG_UI, "AddAttachmentViewController:HandleFinishedPickingMedia: no URL: {0}", ea.Info.ToString ());
                complete ();
                NcAlertView.ShowMessage (PresentingViewController, KCommonFailMessage, KCommonNoAccess);
                return;
            }
        }

        protected class ButtonInfo
        {
            public string buttonLabel { get; set; }

            public string buttonIcon { get; set; }

            public Action buttonAction { get; set; }

            public ButtonInfo (string bl, string bi, Action ba)
            {
                buttonLabel = bl;
                buttonIcon = bi;
                buttonAction = ba;
            }
        }

        //Not perfect but a keeps it from sticking throughtout the app
        protected void MaintainLightStyleStatusBar ()
        {
            UIApplication.SharedApplication.SetStatusBarStyle (UIStatusBarStyle.LightContent, false);
        }

        public void PerformSegueForDelegate (string identifier, NSObject sender)
        {
            PerformSegue (identifier, sender);
        }

        public void RemoveAttachment (McAttachment attachment)
        {
            List<McAttachment> tempList = new List<McAttachment> ();
            foreach (var a in AttachmentsList) {
                if (a.Id != attachment.Id) {
                    tempList.Add (a);
                }
            }
            AttachmentsList = tempList;
        }

        /// <summary>
        /// INachoFileChooserParent delegate
        /// </summary>
        public void DismissChildFileChooser (INachoFileChooser vc)
        {
            vc.DismissFileChooser (true, null);
        }
    }
}