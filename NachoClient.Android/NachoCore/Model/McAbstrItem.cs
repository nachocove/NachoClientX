using System;
using System.Collections.Generic;
using System.Linq;
using SQLite;
using NachoCore.Utils;

namespace NachoCore.Model
{
    // If SQLite.Net would tolerate an abstract class, we'd be one.
    public class McAbstrItem : McAbstrFolderEntry
    {
        // The ClientId is generated by the client, and is constant for the life of the Item.
        // It is meaningless for server-originated messages.
        [Indexed]
        public string ClientId { get; set; }

        [Indexed]
        // The "owner" can record a value here that idicates the conditions under which the entry
        // was created. The owner can then know that later enhancements weren't available when the the
        // entry was created, and take actions. For example, adding street address to device contacts.
        public int OwnerEpoch { get; set; }

        [Indexed]
        public int HasBeenGleaned { get; set; }

        /// Index of Body container
        public int BodyId { get; set; }

        public string BodyPreview { get; set; }

        [Indexed]
        public uint PendingRefCount { get; set; }

        // Platform-specific code sets this when a user-notification is sent.
        public bool HasBeenNotified { get; set; }

        /// The parser blew up when parsing this item, so we know it is missing some fields.
        public bool IsIncomplete { get; set; }

        public McAbstrItem ()
        {
            // TODO - only really need to init ClientId for from-client creations.
            ClientId = Guid.NewGuid ().ToString ("N");
        }

        public enum ItemSource
        {
            Unknown,
            ActiveSync,
            Device,
            User,
            Internal,
            SalesForce,
        };

        public virtual void DeleteAncillary ()
        {
            // Sub-class overrides and adds post-delete ancillary data cleanup.
            // We'd prefer to make this abstract, but SQLite.Net can't tolerate it.
            NcAssert.True (NcModel.Instance.IsInTransaction ());
        }

        private IEnumerable<McAbstrItem> ExistingItems ()
        {
            IEnumerable<McAbstrItem> existingItems = null;
            switch (GetClassCode ()) {
            case ClassCodeEnum.Calendar:
                existingItems = McCalendar.QueryByServerIdMult<McCalendar> (AccountId, ServerId);
                break;
            case ClassCodeEnum.Contact:
                existingItems = McCalendar.QueryByServerIdMult<McContact> (AccountId, ServerId);
                break;
            case ClassCodeEnum.Email:
                existingItems = McCalendar.QueryByServerIdMult<McEmailMessage> (AccountId, ServerId);
                break;
            }
            return (null == existingItems) ? new List<McAbstrItem> () : existingItems;
        }

        public override int Insert ()
        {
            using (var capture = CaptureWithStart ("Insert")) {
                var existingItems = ExistingItems ();
                foreach (var existingItem in existingItems) {
                    NcAssert.True (false, string.Format ("Existing item {0} has ServerId {1}", existingItem.Id, ServerId));
                }
                return base.Insert ();
            }
        }

        public override int Update ()
        {
            using (var capture = CaptureWithStart ("Update")) {
                var existingItems = ExistingItems ();
                foreach (var existingItem in existingItems) {
                    NcAssert.Equals (Id, existingItem.Id);
                }
                return base.Update ();
            }
        }

        public override int Delete ()
        {
            using (var capture = CaptureWithStart ("Delete")) {
                NcAssert.True (100000 > PendingRefCount);
                var returnVal = -1;

                NcModel.Instance.RunInTransaction (() => {
                    McFolder.UnlinkAll (this);
                    if (0 == PendingRefCount) {
                        var result = base.Delete ();
                        if (0 < BodyId) {
                            var body = McBody.QueryById<McBody> (BodyId);
                            if (null != body) {
                                body.Delete ();
                            }
                        }
                        DeleteAncillary ();
                        returnVal = result;
                    } else {
                        if (this is McEmailMessage) {
                            var message = UpdateWithOCApply<McEmailMessage> ((record) => {
                                var target = (McEmailMessage)record;
                                target.IsAwaitingDelete = true;
                                return true;
                            });
                            if (message.IsChat){
                                var chatMessages = McChatMessage.QueryByMessageId (Id);
                                foreach (var chatMessage in chatMessages) {
                                    chatMessage.UpdateLatestDuplicate ();
                                }
                            }
                        } else {
                            IsAwaitingDelete = true;
                            Update ();
                        }
                        returnVal = 0;
                    }
                });

                return returnVal;
            }
        }

        public static IEnumerable<T> QueryByBodyIdIncAwaitDel<T> (int accountId, int bodyId) where T : McAbstrItem, new()
        {
            return NcModel.Instance.Db.Query<T> (
                string.Format ("SELECT f.* FROM {0} AS f WHERE " +
                " likelihood (f.AccountId = ?, 1.0) AND " +
                " likelihood (f.BodyId = ?, 0.001) ",
                    typeof(T).Name), 
                accountId, bodyId);
        }

        public static T QueryByClientId<T> (int accountId, string clientId) where T : McAbstrItem, new()
        {
            return NcModel.Instance.Db.Query<T> (
                string.Format ("SELECT f.* FROM {0} AS f WHERE " +
                " likelihood (f.AccountId = ?, 1.0) AND " +
                " likelihood (f.IsAwaitingDelete = 0, 1.0) AND " +
                " likelihood (f.ClientId = ?, 0.001) ", 
                    typeof(T).Name), 
                accountId, clientId).SingleOrDefault ();
        }

        public static List<T> QueryByFolderId<T> (int accountId, int folderId) where T : McAbstrItem, new()
        {
            return NcModel.Instance.Db.Query<T> (
                string.Format (
                    "SELECT e.* FROM {0} AS e JOIN McMapFolderFolderEntry AS m ON e.Id = m.FolderEntryId WHERE " +
                    " likelihood (e.AccountId = ?, 1.0) AND " +
                    " likelihood (m.AccountId = ?, 1.0) AND " +
                    " likelihood (e.IsAwaitingDelete = 0, 1.0) AND " +
                    " likelihood (m.FolderId = ?, 0.05) ",
                    typeof(T).Name),
                accountId, accountId, folderId);
        }

        public static List<T> QueryOldEpochByFolderId<T> (int accountId, int folderId, int currentEpoch, int limit) where T : McAbstrItem, new()
        {
            return NcModel.Instance.Db.Query<T> (
                string.Format (
                    "SELECT e.* FROM {0} AS e JOIN McMapFolderFolderEntry AS m ON e.Id = m.FolderEntryId WHERE " +
                    " likelihood (e.AccountId = ?, 1.0) AND " +
                    " likelihood (m.AccountId = ?, 1.0) AND " +
                    " likelihood (e.IsAwaitingDelete = 0, 1.0) AND " +
                    " likelihood (m.FolderId = ?, 0.05) AND " +
                    " likelihood (m.AsSyncEpoch < ?, 0.5) " +
                    " LIMIT ? ",
                    typeof(T).Name),
                accountId, accountId, folderId, currentEpoch, limit);
        }

        public McBody GetBody ()
        {
            if (0 == BodyId) {
                return null;
            }
            return McBody.QueryById<McBody> (BodyId);
        }

        public string GetBodyPreviewOrEmpty ()
        {
            if (null == BodyPreview) {
                return String.Empty;
            } else {
                return BodyPreview;
            }
        }

        public override ClassCodeEnum GetClassCode ()
        {
            // Sub-class needs to override if it is to be folder link-able.
            return ClassCodeEnum.NeverInFolder;
        }

        // *******************************************************************************
        // Generic routines that provide the algorithms for managing a collection of items
        // that are ancillary to (a.k.a. children of) this item.  The pieces of code that
        // depend on the specific type of the ancillary item are passed in as delegates.
        // *******************************************************************************

        protected delegate List<T> CollectionFromDbDelegate<T> ();

        protected void ReadAncillaryCollection<T> (
            ref List<T> dbCollection, CollectionFromDbDelegate<T> CollectionFromDb)
            where T : McAbstrObjectPerAcc
        {
            if (null == dbCollection) {
                if (0 == this.Id) {
                    dbCollection = new List<T> ();
                } else {
                    dbCollection = CollectionFromDb ();
                }
            }
        }

        protected IList<T> GetAncillaryCollection<T> (
            IList<T> appCollection, ref List<T> dbCollection, CollectionFromDbDelegate<T> CollectionFromDb)
            where T : McAbstrObjectPerAcc
        {
            if (null != appCollection) {
                return appCollection;
            }
            ReadAncillaryCollection (ref dbCollection, CollectionFromDb);
            return dbCollection.AsReadOnly ();
        }

        protected void DeleteAncillaryCollection<T> (
            ref List<T> dbCollection, CollectionFromDbDelegate<T> CollectionFromDb)
            where T : McAbstrObjectPerAcc
        {
            ReadAncillaryCollection (ref dbCollection, CollectionFromDb);
            foreach (var item in dbCollection) {
                item.Delete ();
            }
            dbCollection = null;
        }

        protected delegate void InitializeItemDelegate<T> (T item);

        protected delegate bool CheckItemDelegate<T> (T item);

        protected void SaveAncillaryCollection<T> (
            ref IList<T> appCollection, ref List<T> dbCollection, CollectionFromDbDelegate<T> CollectionFromDb, InitializeItemDelegate<T> InitializeItem, CheckItemDelegate<T> CheckItem)
            where T : McAbstrObjectPerAcc
        {
            if (null == appCollection) {
                return;
            }
            ReadAncillaryCollection (ref dbCollection, CollectionFromDb);
            HashSet<int> reusedItemIds = new HashSet<int> ();
            foreach (var item in appCollection) {
                if (0 == item.Id) {
                    InitializeItem (item);
                    item.Insert ();
                } else {
                    NcAssert.True (CheckItem (item), "An ancillary item is being transfered from one parent item to another.");
                    item.Update ();
                    reusedItemIds.Add (item.Id);
                }
            }
            foreach (var dbItem in dbCollection) {
                if (!reusedItemIds.Contains (dbItem.Id)) {
                    dbItem.Delete ();
                }
            }
            dbCollection = new List<T> (appCollection);
            appCollection = null;
        }

        protected void InsertAncillaryCollection<T> (
            ref IList<T> appCollection, ref List<T> dbCollection, InitializeItemDelegate<T> InitializeItem)
            where T : McAbstrObjectPerAcc
        {
            if (null == appCollection) {
                dbCollection = new List<T> ();
                return;
            }
            foreach (var item in appCollection) {
                NcAssert.True (0 == item.Id);
                InitializeItem (item);
                item.Insert ();
            }
            dbCollection = new List<T> (appCollection);
            appCollection = null;
        }

        public static McAbstrItem RefreshItem (McAbstrItem item)
        {
            McAbstrItem refreshedItem;
            if (item is McEmailMessage) {
                refreshedItem = McEmailMessage.QueryById<McEmailMessage> (item.Id);
            } else if (item is McCalendar) {
                refreshedItem = McCalendar.QueryById<McCalendar> (item.Id);
            } else if (item is McException) {
                refreshedItem = McException.QueryById<McException> (item.Id);
            } else {
                throw new NcAssert.NachoDefaultCaseFailure (
                    string.Format ("Unhandled abstract item type {0}", item.GetType ().Name));
            }
            return refreshedItem;
        }
    }
}

